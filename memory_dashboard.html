<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Memory Intelligence Dashboard - Hyperscaler Memory & Education Integration</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e2e8f0;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: #2d3748;
            border-radius: 15px;
            padding: 40px 40px 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #4a5568;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            color: #a0aec0;
        }

        /* Module Navigation */
        .module-nav {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .module-btn {
            padding: 12px 24px;
            background: #1a202c;
            border: 2px solid #4a5568;
            border-radius: 8px;
            color: #a0aec0;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .module-btn:hover, .module-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
            transform: translateY(-2px);
        }

        /* Dashboard Sections */
        .dashboard-section {
            margin-bottom: 35px;
            display: none;
        }

        .dashboard-section.active {
            display: block;
        }

        .section-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4a5568;
        }

        /* Stats Grid */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #1a202c;
            border: 2px solid #4a5568;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: #667eea;
            transform: translateY(-3px);
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #a0aec0;
        }

        /* Alerts Panel */
        .alerts-panel {
            background: rgba(229, 62, 62, 0.1);
            border: 2px solid #e53e3e;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .alert-item {
            padding: 12px;
            margin-bottom: 10px;
            background: #1a202c;
            border-radius: 8px;
            border-left: 4px solid #e53e3e;
        }

        .alert-item.warning {
            border-left-color: #ed8936;
        }

        .alert-item.info {
            border-left-color: #667eea;
        }

        .alert-title {
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 5px;
        }

        .alert-message {
            color: #a0aec0;
            font-size: 0.9rem;
        }

        /* Card Grids */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }

        .metric-card {
            background: #1a202c;
            border: 2px solid #4a5568;
            border-radius: 12px;
            padding: 25px;
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3);
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .metric-name {
            font-size: 1.1rem;
            font-weight: 700;
            color: #e2e8f0;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #667eea;
        }

        .metric-description {
            color: #a0aec0;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Chart Containers */
        .chart-container {
            background: #1a202c;
            border: 2px solid #4a5568;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            min-height: 400px;
            position: relative;
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }

        .chart-title-secondary {
            font-size: 0.8rem;
            font-weight: 500;
            color: #a0aec0;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #4a5568;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .legend-text {
            font-size: 0.85rem;
            color: #a0aec0;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(26, 32, 44, 0.98);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 12px;
            pointer-events: none;
            z-index: 1000;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .tooltip-title {
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .tooltip-item {
            color: #a0aec0;
            font-size: 0.85rem;
            margin: 4px 0;
            line-height: 1.5;
        }

        .tooltip-item strong {
            color: #e2e8f0;
        }

        /* Annotations */
        .annotation {
            position: absolute;
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.75rem;
            color: #e2e8f0;
            pointer-events: none;
            z-index: 100;
        }

        /* Chart Info Panel */
        .chart-info {
            background: rgba(102, 126, 234, 0.05);
            border: 1px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.9rem;
            color: #a0aec0;
            line-height: 1.6;
        }

        /* Chart Rationale */
        .chart-rationale {
            background: rgba(102, 126, 234, 0.08);
            border-left: 4px solid #667eea;
            border-radius: 8px;
            padding: 0;
            margin-top: 25px;
            font-size: 0.95rem;
            color: #e2e8f0;
            line-height: 1.8;
        }

        .chart-rationale-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            background: rgba(102, 126, 234, 0.15);
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(102, 126, 234, 0.3);
        }

        .chart-rationale-header:hover {
            background: rgba(102, 126, 234, 0.25);
        }

        .chart-rationale-header-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-rationale-header-title::before {
            content: "ℹ";
            font-size: 1.2rem;
            color: #667eea;
        }

        .chart-rationale-header-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            color: #a0aec0;
        }

        .chart-rationale-header-icon {
            font-size: 0.9rem;
            color: #667eea;
            font-weight: 700;
            transition: transform 0.3s ease;
        }

        .chart-rationale-content-wrapper {
            padding: 20px;
            display: none;
        }

        .chart-rationale-content-wrapper.expanded {
            display: block;
        }

        .chart-rationale-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-rationale-title::before {
            content: "ℹ";
            font-size: 1.2rem;
            color: #667eea;
        }

        .chart-rationale-content {
            margin-bottom: 15px;
        }

        .chart-rationale-content p {
            margin-bottom: 10px;
        }

        .chart-rationale-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(102, 126, 234, 0.3);
        }

        .chart-rationale-section strong {
            color: #667eea;
            display: block;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .chart-rationale-list {
            list-style: none;
            padding-left: 0;
            margin-top: 8px;
        }

        .chart-rationale-list li {
            margin: 6px 0;
            padding-left: 20px;
            position: relative;
        }

        .chart-rationale-list li::before {
            content: "→";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: 700;
        }

        /* Footer */
        .footer {
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #4a5568;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 10px;
            font-size: 0.8rem;
            color: #a0aec0;
        }

        .footer-left,
        .footer-right {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .footer-separator {
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .footer {
                flex-direction: column;
                align-items: flex-start;
            }

            .footer-right {
                margin-top: 4px;
            }
        }

        /* Heatmap */
        .heatmap-container {
            background: #1a202c;
            border: 2px solid #4a5568;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            overflow: visible;
        }

        /* 2x2 Matrix */
        .matrix-container {
            background: #1a202c;
            border: 2px solid #4a5568;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            min-height: 500px;
        }

        /* Node-link Graph */
        .graph-container {
            background: #1a202c;
            border: 2px solid #4a5568;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            min-height: 500px;
        }

        /* Provider Badges */
        .provider-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            margin-right: 8px;
        }

        .provider-google {
            background: #4285f4;
            color: white;
        }

        .provider-microsoft {
            background: #00a4ef;
            color: white;
        }

        .provider-apple {
            background: #000000;
            color: white;
        }

        .provider-openai {
            background: #ff6b35;
            color: white;
        }

        .provider-anthropic {
            background: #d4a574;
            color: white;
        }

        /* Risk Indicators */
        .risk-low { color: #48bb78; }
        .risk-medium { color: #ed8936; }
        .risk-high { color: #e53e3e; }

        /* Opportunity Quadrant */
        .quadrant {
            position: relative;
            width: 100%;
            height: 500px;
            border: 2px solid #4a5568;
            border-radius: 12px;
            background: #1a202c;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #1a202c;
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            color: #a0aec0;
            font-weight: 600;
        }

        .control-group select, .control-group input {
            padding: 8px 12px;
            border: 2px solid #4a5568;
            border-radius: 6px;
            background: #2d3748;
            color: #e2e8f0;
            font-size: 0.9rem;
        }

        .control-group button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .control-group button:hover {
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>AI Memory Intelligence Dashboard</h1>
            <p>Hyperscaler Memory Architecture & Education Integration Analysis</p>
            <p style="font-size: 0.9rem; color: #48bb78; margin-top: 10px;">✓ Tracking 3 modules: Ecosystem Moves | Memory Architecture | Education Integration</p>
        </div>

        <!-- Module Navigation -->
        <div class="module-nav">
            <button class="module-btn active" onclick="showModule('ecosystem')">Ecosystem Moves</button>
            <button class="module-btn" onclick="showModule('memory')">Memory Architecture</button>
            <button class="module-btn" onclick="showModule('education')">Education Integration</button>
        </div>

        <!-- Module 1: Ecosystem Moves -->
        <div id="module-ecosystem" class="dashboard-section active">
            <h2 class="section-title">Module 1: Ecosystem Moves</h2>
            <p style="color: #a0aec0; margin-bottom: 20px;">
                Tracking hyperscaler releases, capabilities, and strategic patterns
            </p>

            <!-- Controls -->
            <div class="controls">
                <div class="control-group">
                    <label>Provider:</label>
                    <select id="ecosystemProviderFilter">
                        <option value="all">All Providers</option>
                        <option value="Google">Google</option>
                        <option value="Microsoft">Microsoft</option>
                        <option value="OpenAI">OpenAI</option>
                        <option value="Anthropic">Anthropic</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Timeframe:</label>
                    <select id="ecosystemTimeframeFilter">
                        <option value="quarter">Last Quarter</option>
                        <option value="month">Last Month</option>
                        <option value="year">Last Year</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
            </div>

            <!-- Alerts -->
            <div class="alerts-panel" id="ecosystemAlerts">
                <!-- Alerts will be dynamically inserted -->
            </div>

            <!-- Core Metrics -->
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="ecosystemMemoryReleases">0</div>
                    <div class="stat-label">Memory Releases</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="ecosystemAgentFeatures">0</div>
                    <div class="stat-label">Agent Features</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="ecosystemIdentityExpansions">0</div>
                    <div class="stat-label">Identity Expansions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="ecosystemAPIGrowth">0</div>
                    <div class="stat-label">API Endpoints</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="ecosystemConvergenceCount">0</div>
                    <div class="stat-label">Convergence Events</div>
                </div>
            </div>

            <!-- Growth of Memory-Related Product Releases -->
            <div class="chart-container">
                <div class="chart-title">Growth of Memory-Related Product Releases (2023–2025)</div>
                <div id="ecosystemMemoryGrowthChart"></div>
            </div>

            <!-- Chart B: Memory Release Timeline (2024–2025) -->
            <div class="chart-container">
                <div class="chart-title">Memory Release Timeline (Multi-line Time Series, 2024–2025)</div>
                <div id="ecosystemTimelineChart"></div>
            </div>

            <!-- Chart B: Agent Feature Velocity -->
            <div class="chart-container">
                <div class="chart-title">Agent Feature Velocity (Features per Provider per Quarter)</div>
                <div id="ecosystemAgentVelocityChart"></div>
            </div>
        </div>

        <!-- Module 2: Memory Architecture -->
        <div id="module-memory" class="dashboard-section">
            <h2 class="section-title">Module 2: Memory Architecture</h2>
            <p style="color: #a0aec0; margin-bottom: 20px;">
                Quantifying how deep, open, and risky each platform's memory layer is
            </p>

            <!-- Controls -->
            <div class="controls">
                <div class="control-group">
                    <label>Provider:</label>
                    <select id="memoryProviderFilter">
                        <option value="all">All Providers</option>
                        <option value="Google">Google</option>
                        <option value="Microsoft">Microsoft</option>
                        <option value="OpenAI">OpenAI</option>
                        <option value="Anthropic">Anthropic</option>
                    </select>
                </div>
            </div>

            <!-- Alerts -->
            <div class="alerts-panel" id="memoryAlerts">
                <!-- Alerts will be dynamically inserted -->
            </div>

            <!-- Core Metrics -->
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="memoryLockInIndex">0</div>
                    <div class="stat-label">Identity Lock-In Index</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="memoryOpennessScore">0</div>
                    <div class="stat-label">Memory Openness Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="memoryRecallDepth">0</div>
                    <div class="stat-label">Recall Depth (tokens)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="memoryBoundariesScore">0</div>
                    <div class="stat-label">Boundaries Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="memoryCrossAppReach">0</div>
                    <div class="stat-label">Cross-App Memory Reach</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="memoryDefaultOnRate">0%</div>
                    <div class="stat-label">Default-On Rate</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="memoryVisibilityIndex">0</div>
                    <div class="stat-label">User Visibility Index</div>
                </div>
            </div>

            <!-- Chart A: Memory Openness vs Lock-In (2x2 Matrix) -->
            <div class="matrix-container">
                <div class="chart-title">Memory Openness vs Lock-In Matrix</div>
                <div id="memoryOpennessMatrix"></div>
            </div>

            <!-- Chart B: Cross-App Memory Reach Graph -->
            <div class="graph-container">
                <div class="chart-title">Cross-App Memory Reach (Node-Link Graph)</div>
                <div id="memoryCrossAppGraph"></div>
            </div>

            <!-- Chart D: Effective Recall Depth Trendline -->
            <div class="chart-container">
                <div class="chart-title">Effective Recall Depth Trendline (Tied to Model Versions)</div>
                <div id="memoryRecallDepthChart"></div>
            </div>
        </div>

        <!-- Module 3: Education Integration -->
        <div id="module-education" class="dashboard-section">
            <h2 class="section-title">Module 3: Education Integration</h2>
            <p style="color: #a0aec0; margin-bottom: 20px;">
                Tracking how deeply each hyperscaler is embedding AI into education workflows
            </p>

            <!-- Controls -->
            <div class="controls">
                <div class="control-group">
                    <label>Provider:</label>
                    <select id="educationProviderFilter">
                        <option value="all">All Providers</option>
                        <option value="Google">Google</option>
                        <option value="Microsoft">Microsoft</option>
                        <option value="OpenAI">OpenAI</option>
                        <option value="Anthropic">Anthropic</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Education Level:</label>
                    <select id="educationLevelFilter">
                        <option value="all">All Levels</option>
                        <option value="K-12">K-12</option>
                        <option value="Higher Ed">Higher Ed</option>
                    </select>
                </div>
            </div>

            <!-- Alerts -->
            <div class="alerts-panel" id="educationAlerts">
                <!-- Alerts will be dynamically inserted -->
            </div>

            <!-- Core Metrics -->
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="educationIntegrationScore">0</div>
                    <div class="stat-label">EDU Integration Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="educationLMSIntegrations">0</div>
                    <div class="stat-label">LMS/SIS Integrations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="educationWorkflowCoverage">0%</div>
                    <div class="stat-label">Workflow Coverage</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="educationDistrictPenetration">0%</div>
                    <div class="stat-label">District Penetration</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="educationAgentWorkloads">0</div>
                    <div class="stat-label">Agent EDU Workloads</div>
                </div>
            </div>

            <!-- Chart A: Education Integration Dashboard (Heatmap) -->
            <div class="heatmap-container">
                <div class="chart-title">Education Integration Heatmap (Providers × EDU Use Cases)</div>
                <div id="educationIntegrationHeatmap"></div>
            </div>

            <!-- Chart B: Ecosystem Risk View -->
            <div class="chart-container">
                <div class="chart-title">Ecosystem Risk View (Default Context Layer Distribution)</div>
                <div id="educationEcosystemRiskChart"></div>
            </div>

            <!-- Chart C: Public-Good Risk Gradient -->
            <div class="heatmap-container">
                <div class="chart-title">Public-Good Risk Gradient</div>
                <div id="educationPublicGoodRiskGradient"></div>
            </div>

        </div>

        <div class="footer">
            <div class="footer-left">
                <span>AI Memory Intelligence Dashboard</span>
                <span class="footer-separator">•</span>
                <span>Hyperscaler memory and education integration monitoring</span>
            </div>
            <div class="footer-right">
                <span>Responsive view:</span>
                <span>Use module toggles above to focus on Ecosystem, Memory, or Education.</span>
            </div>
        </div>
    </div>

    <script>
        // Comprehensive data structure for all modules
        const dashboardData = {
            ecosystem: {
                releases: [
                    { 
                        id: 'r1', provider: 'Google', featureType: 'memory', date: '2024-01-15', 
                        feature: 'Gemini Memory API', description: 'Persistent memory for agents',
                        details: 'Enables agents to maintain context across conversations. Supports up to 128K tokens. Includes automatic summarization and retrieval.',
                        impact: 'high', tokens: 128000, adoptionRate: 45, apiEndpoints: 12,
                        linkedFeatures: ['Workspace Graph', 'AI Studio'], regions: ['US', 'EU', 'APAC']
                    },
                    { 
                        id: 'r2', provider: 'Microsoft', featureType: 'memory', date: '2024-02-10', 
                        feature: 'Copilot Memory Layer', description: 'Cross-app memory storage',
                        details: 'Unified memory system across M365 apps. Enables context sharing between Word, Excel, PowerPoint, Teams. 200K token capacity.',
                        impact: 'high', tokens: 200000, adoptionRate: 52, apiEndpoints: 18,
                        linkedFeatures: ['M365 Graph', 'Copilot Studio'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r3', provider: 'Google', featureType: 'agent', date: '2024-01-20', 
                        feature: 'AI Studio', description: 'Agent builder platform',
                        details: 'Visual agent builder with memory integration. Supports multi-turn conversations. Includes testing and deployment tools.',
                        impact: 'high', tokens: 0, adoptionRate: 38, apiEndpoints: 25,
                        linkedFeatures: ['Gemini Memory API', 'Workspace'], regions: ['US', 'EU', 'APAC']
                    },
                    { 
                        id: 'r4', provider: 'Microsoft', featureType: 'agent', date: '2024-02-15', 
                        feature: 'Copilot Studio', description: 'Custom agent creation',
                        details: 'Low-code agent builder for enterprise. Integrates with M365 memory layer. Supports custom prompts and workflows.',
                        impact: 'high', tokens: 0, adoptionRate: 42, apiEndpoints: 22,
                        linkedFeatures: ['Copilot Memory', 'Power Platform'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r5', provider: 'Google', featureType: 'identity', date: '2024-03-05', 
                        feature: 'Workspace Graph Expansion', description: 'Enhanced identity linking',
                        details: 'Expanded identity graph connects more Google services. New permission scopes for cross-app access. Enhanced privacy controls.',
                        impact: 'medium', tokens: 0, adoptionRate: 65, apiEndpoints: 15,
                        linkedFeatures: ['Workspace', 'Identity Platform'], regions: ['Global']
                    },
                    { 
                        id: 'r7', provider: 'Google', featureType: 'api', date: '2024-04-10', 
                        feature: 'Graph API Expansion', description: 'New permission scopes',
                        details: 'Added 12 new API endpoints for memory access. Enhanced OAuth scopes. Improved rate limits for enterprise customers.',
                        impact: 'medium', tokens: 0, adoptionRate: 55, apiEndpoints: 12,
                        linkedFeatures: ['Workspace Graph', 'API Platform'], regions: ['Global']
                    },
                    { 
                        id: 'r8', provider: 'Microsoft', featureType: 'identity', date: '2024-04-15', 
                        feature: 'M365 Graph Integration', description: 'Account context binding',
                        details: 'Deep integration with Azure AD and M365 Graph. Enhanced account context for memory storage. New identity federation options.',
                        impact: 'medium', tokens: 0, adoptionRate: 58, apiEndpoints: 14,
                        linkedFeatures: ['Azure AD', 'M365 Graph'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r9', provider: 'Google', featureType: 'memory', date: '2024-05-01', 
                        feature: 'Memory TTL Controls', description: 'Time-to-live settings',
                        details: 'Granular TTL controls for memory retention. Automatic expiration policies. Enhanced deletion options for compliance.',
                        impact: 'low', tokens: 0, adoptionRate: 48, apiEndpoints: 6,
                        linkedFeatures: ['Gemini Memory API'], regions: ['Global']
                    },
                    { 
                        id: 'r10', provider: 'OpenAI', featureType: 'agent', date: '2024-05-10', 
                        feature: 'GPT-4 Assistants API', description: 'Agent platform with memory',
                        details: 'Assistants API with persistent memory across conversations. Integrated with ChatGPT, custom GPTs. 128K token memory.',
                        impact: 'high', tokens: 128000, adoptionRate: 55, apiEndpoints: 12,
                        linkedFeatures: ['ChatGPT', 'GPTs'], regions: ['Global']
                    },
                    { 
                        id: 'r11', provider: 'Microsoft', featureType: 'memory', date: '2024-05-20', 
                        feature: 'Memory Export API', description: 'Data portability feature',
                        details: 'New API for exporting memory data in standard formats (JSON, CSV). Supports GDPR compliance. Includes encryption options.',
                        impact: 'medium', tokens: 0, adoptionRate: 32, apiEndpoints: 4,
                        linkedFeatures: ['Copilot Memory'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r12', provider: 'Google', featureType: 'safety', date: '2024-06-01', 
                        feature: 'Memory Governance', description: 'Compliance controls',
                        details: 'Comprehensive governance controls for memory storage. Audit logs, access controls, content filtering. SOC 2 compliant.',
                        impact: 'high', tokens: 0, adoptionRate: 72, apiEndpoints: 8,
                        linkedFeatures: ['Gemini Memory API', 'Admin Console'], regions: ['Global']
                    },
                    { 
                        id: 'r13', provider: 'OpenAI', featureType: 'memory', date: '2024-08-05', 
                        feature: 'ChatGPT Org Memory', description: 'Organizational memory for ChatGPT workspaces',
                        details: 'Enables shared memory across teams within a ChatGPT workspace. Includes admin controls and export tools.',
                        impact: 'high', tokens: 150000, adoptionRate: 37, apiEndpoints: 10,
                        linkedFeatures: ['ChatGPT Teams', 'Assistant Memory API'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r14', provider: 'Microsoft', featureType: 'identity', date: '2024-09-12', 
                        feature: 'Edu Graph Binding', description: 'Education tenant identity binding',
                        details: 'Binds student and teacher identities more tightly to M365 Graph for EDU tenants, enabling cross-app memory defaults.',
                        impact: 'high', tokens: 0, adoptionRate: 41, apiEndpoints: 9,
                        linkedFeatures: ['M365 EDU', 'Copilot for Education'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r15', provider: 'Google', featureType: 'memory', date: '2025-02-18', 
                        feature: 'Classroom Long-Term Memory', description: 'Multi-year student memory in Classroom',
                        details: 'Retains multi-year learning trajectories for students, with educator-facing controls and retention policies.',
                        impact: 'high', tokens: 220000, adoptionRate: 29, apiEndpoints: 11,
                        linkedFeatures: ['Google Classroom', 'Workspace Graph'], regions: ['Global']
                    },
                    { 
                        id: 'r16', provider: 'Anthropic', featureType: 'api', date: '2025-06-03', 
                        feature: 'Claude Memory Webhooks', description: 'Event-driven memory integration',
                        details: 'Webhooks for memory read/write events, enabling external systems to sync or audit Claude memory activity.',
                        impact: 'medium', tokens: 0, adoptionRate: 18, apiEndpoints: 7,
                        linkedFeatures: ['Claude API', 'Audit Toolkit'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r17', provider: 'Anthropic', featureType: 'memory', date: '2024-10-20', 
                        feature: 'Claude EDU Memory Profiles', description: 'Education-focused memory profiles for Claude',
                        details: 'Allows institutions to define scoped memory profiles for different student cohorts, with strict retention and audit controls.',
                        impact: 'high', tokens: 160000, adoptionRate: 21, apiEndpoints: 8,
                        linkedFeatures: ['Claude EDU', 'Policy Toolkit'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r18', provider: 'Microsoft', featureType: 'safety', date: '2025-03-30', 
                        feature: 'Memory Risk Dashboard', description: 'Safety analytics for memory usage',
                        details: 'Dashboard for monitoring risky memory patterns across tenants, with exportable reports and automated policy suggestions.',
                        impact: 'medium', tokens: 0, adoptionRate: 33, apiEndpoints: 5,
                        linkedFeatures: ['Security Center', 'Copilot Memory'], regions: ['Global']
                    },
                    { 
                        id: 'r19', provider: 'OpenAI', featureType: 'api', date: '2025-09-01', 
                        feature: 'Memory Policy API', description: 'Programmatic control over memory retention and access',
                        details: 'API for setting per-tenant memory policies, including TTLs, scopes, export requirements, and jurisdictional constraints.',
                        impact: 'high', tokens: 0, adoptionRate: 19, apiEndpoints: 9,
                        linkedFeatures: ['Assistant Memory API', 'Compliance Toolkit'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r20', provider: 'Google', featureType: 'safety', date: '2024-07-10', 
                        feature: 'Student Memory Transparency Panel', description: 'Student-facing memory transparency tools',
                        details: 'Dashboard inside Classroom that shows students what the system remembers, with one-click deletion and export controls.',
                        impact: 'medium', tokens: 0, adoptionRate: 24, apiEndpoints: 4,
                        linkedFeatures: ['Google Classroom', 'Privacy Center'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r21', provider: 'Microsoft', featureType: 'memory', date: '2025-08-05', 
                        feature: 'Copilot Scenario Memory', description: 'Task- and scenario-scoped memories',
                        details: 'Allows tenants to define scenario-specific memories (e.g., IEP planning, grading) with strict boundaries and retention rules.',
                        impact: 'high', tokens: 180000, adoptionRate: 23, apiEndpoints: 6,
                        linkedFeatures: ['M365 EDU', 'Copilot Memory'], regions: ['Global']
                    },
                    { 
                        id: 'r22', provider: 'Google', featureType: 'agent', date: '2024-07-22', 
                        feature: 'Gemini Classroom Coach', description: 'In-class agent powered by Classroom memory',
                        details: 'Context-aware coach for teachers that uses Classroom memory to suggest interventions and resources in real time.',
                        impact: 'high', tokens: 0, adoptionRate: 26, apiEndpoints: 9,
                        linkedFeatures: ['Google Classroom', 'Gemini Memory API'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r23', provider: 'Microsoft', featureType: 'agent', date: '2024-10-05', 
                        feature: 'Teams EDU Memory Assistant', description: 'Meeting assistant with EDU memory context',
                        details: 'Captures and summarizes EDU-specific meetings (IEP, PLC, department planning) with memory-aware action items.',
                        impact: 'high', tokens: 0, adoptionRate: 28, apiEndpoints: 8,
                        linkedFeatures: ['Teams', 'Copilot Memory'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r24', provider: 'OpenAI', featureType: 'safety', date: '2025-01-30', 
                        feature: 'Memory Compliance Scanner', description: 'Automated scanning of memory for policy violations',
                        details: 'Scans tenant memory stores for policy violations and PII exposure, with remediation workflows and alerts.',
                        impact: 'medium', tokens: 0, adoptionRate: 20, apiEndpoints: 6,
                        linkedFeatures: ['Memory Policy API', 'Compliance Toolkit'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r25', provider: 'Anthropic', featureType: 'identity', date: '2025-04-18', 
                        feature: 'Claude EDU Identity Bridge', description: 'Bridge between district identity and Claude memory',
                        details: 'Lightweight identity bridge that links district accounts to Claude memory with explicit consent flows and per-role scopes.',
                        impact: 'medium', tokens: 0, adoptionRate: 17, apiEndpoints: 5,
                        linkedFeatures: ['Claude EDU', 'Identity Bridge'], regions: ['US']
                    },
                    { 
                        id: 'r26', provider: 'Google', featureType: 'memory', date: '2025-09-12', 
                        feature: 'Workspace Memory Snapshots', description: 'Periodic snapshots of memory state for audit and rollback',
                        details: 'Creates periodic snapshots of Workspace memory to support auditing, rollback, and research on longitudinal learning patterns.',
                        impact: 'high', tokens: 260000, adoptionRate: 16, apiEndpoints: 7,
                        linkedFeatures: ['Workspace Graph', 'Admin Console'], regions: ['Global']
                    },
                    { 
                        id: 'r27', provider: 'OpenAI', featureType: 'memory', date: '2024-07-28', 
                        feature: 'Tutor Session Memory', description: 'Session-scoped memory for tutoring scenarios',
                        details: 'Stores multi-session tutoring context for students using ChatGPT-based tutors, with clear session boundaries and expiration.',
                        impact: 'high', tokens: 120000, adoptionRate: 22, apiEndpoints: 6,
                        linkedFeatures: ['ChatGPT Tutors', 'Assistant Memory API'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r28', provider: 'Microsoft', featureType: 'api', date: '2024-11-09', 
                        feature: 'Memory Insights API', description: 'API for querying memory usage analytics',
                        details: 'Provides aggregated insights about memory usage patterns across workloads, including EDU-specific metrics.',
                        impact: 'medium', tokens: 0, adoptionRate: 19, apiEndpoints: 8,
                        linkedFeatures: ['Memory Risk Dashboard', 'Security Center'], regions: ['Global']
                    },
                    { 
                        id: 'r29', provider: 'Anthropic', featureType: 'safety', date: '2025-02-22', 
                        feature: 'Claude Memory Red-Team Reports', description: 'Red-team analysis of memory behavior',
                        details: 'Publishes periodic red-team reports on memory misuse and mitigations, with hooks for policy updates.',
                        impact: 'medium', tokens: 0, adoptionRate: 14, apiEndpoints: 3,
                        linkedFeatures: ['Claude API', 'Policy Toolkit'], regions: ['US', 'EU']
                    },
                    { 
                        id: 'r30', provider: 'Google', featureType: 'identity', date: '2025-07-03', 
                        feature: 'Guardian Consent Flows', description: 'Consent and override flows for student memory',
                        details: 'Introduces guardian and district consent flows that gate which student memories can be persisted and for how long.',
                        impact: 'high', tokens: 0, adoptionRate: 27, apiEndpoints: 5,
                        linkedFeatures: ['Privacy Center', 'Workspace Graph'], regions: ['US']
                    },
                    { 
                        id: 'r31', provider: 'OpenAI', featureType: 'agent', date: '2025-10-05', 
                        feature: 'Advisor Memory Packs', description: 'Pre-configured memory packs for advising scenarios',
                        details: 'Advising-focused memory packs (college counseling, career pathways) managed as modular units that can be enabled per institution.',
                        impact: 'high', tokens: 140000, adoptionRate: 18, apiEndpoints: 7,
                        linkedFeatures: ['Advisor Agents', 'Memory Policy API'], regions: ['US', 'EU']
                    }
                ],
                memoryGrowthByYear: {
                    2023: { total: 4, byProvider: { Google: 1, Microsoft: 1, OpenAI: 1, Anthropic: 1 } },
                    2024: { total: 12, byProvider: { Google: 5, Microsoft: 4, OpenAI: 2, Anthropic: 1 } },
                    2025: { total: 22, byProvider: { Google: 8, Microsoft: 8, OpenAI: 4, Anthropic: 2 } }
                },
                memoryProductsByYear: {
                    2023: [
                        { provider: 'Google', product: 'Bard Memory Context', date: '2024-01-21', description: 'Initial memory context feature for Bard conversations', announcement: 'Google I/O 2024', category: 'Conversational Memory' },
                        { provider: 'Microsoft', product: 'Bing Chat Memory', date: '2024-02-04', description: 'Persistent memory across Bing Chat sessions', announcement: 'Microsoft Build 2024', category: 'Search Memory' },
                        { provider: 'OpenAI', product: 'GPT-4 Memory API', date: '2024-03-18', description: 'Memory API for GPT-4 applications and assistants', announcement: 'OpenAI Developer Day 2024', category: 'Agent Memory' },
                        { provider: 'Anthropic', product: 'Claude Memory System', date: '2024-04-15', description: 'Persistent memory for Claude conversations', announcement: 'Anthropic Product Launch 2024', category: 'Conversational Memory' }
                    ],
                    2024: [
                        { provider: 'Google', product: 'Gemini Memory API', date: '2024-01-15', description: 'Persistent memory for agents, 128K tokens', announcement: 'Google Cloud Next', category: 'Agent Memory' },
                        { provider: 'Google', product: 'Workspace Memory Integration', date: '2024-02-20', description: 'Memory integration across Workspace apps', announcement: 'Google Workspace Update', category: 'Productivity Memory' },
                        { provider: 'Google', product: 'Memory TTL Controls', date: '2024-05-01', description: 'Time-to-live settings for memory retention', announcement: 'Google I/O 2024', category: 'Memory Governance' },
                        { provider: 'Google', product: 'Classroom Memory Context', date: '2024-06-10', description: 'Student context memory in Google Classroom', announcement: 'Google for Education', category: 'Education Memory' },
                        { provider: 'Google', product: 'Gemini Memory Expansion', date: '2024-09-15', description: 'Extended memory capacity to 200K tokens', announcement: 'Google Cloud Next', category: 'Memory Capacity' },
                        { provider: 'Microsoft', product: 'Copilot Memory Layer', date: '2024-02-10', description: 'Cross-app memory storage, 200K tokens', announcement: 'Microsoft Build 2024', category: 'Productivity Memory' },
                        { provider: 'Microsoft', product: 'Memory Export API', date: '2024-05-20', description: 'Data portability for memory export', announcement: 'Microsoft Build 2024', category: 'Memory Governance' },
                        { provider: 'Microsoft', product: 'Teams Memory Integration', date: '2024-07-18', description: 'Persistent memory in Teams conversations', announcement: 'Microsoft Ignite', category: 'Collaboration Memory' },
                        { provider: 'Microsoft', product: 'Edge Memory Context', date: '2024-10-22', description: 'Browser-based memory for Edge Copilot', announcement: 'Microsoft Edge Update', category: 'Browser Memory' },
                        { provider: 'OpenAI', product: 'GPT-4 Memory v2', date: '2024-04-12', description: 'Enhanced memory system for GPT-4 assistants', announcement: 'OpenAI Developer Update', category: 'Agent Memory' },
                        { provider: 'OpenAI', product: 'ChatGPT Memory Context', date: '2024-08-14', description: 'Persistent memory in ChatGPT conversations', announcement: 'OpenAI Product Launch', category: 'Conversational Memory' },
                        { provider: 'Anthropic', product: 'Claude Memory API', date: '2024-06-05', description: 'Memory API for Claude-based applications', announcement: 'Anthropic Developer Platform', category: 'Agent Memory' }
                    ],
                    2025: [
                        { provider: 'Google', product: 'Gemini Memory API v2', date: '2025-01-10', description: 'Enhanced memory API with 500K token capacity', announcement: 'Google Cloud Next', category: 'Agent Memory' },
                        { provider: 'Google', product: 'Gmail Memory Integration', date: '2025-01-25', description: 'Email context memory in Gmail', announcement: 'Google Workspace Update', category: 'Email Memory' },
                        { provider: 'Google', product: 'Docs Memory Context', date: '2025-02-14', description: 'Document-aware memory in Google Docs', announcement: 'Google Workspace Update', category: 'Document Memory' },
                        { provider: 'Google', product: 'Sheets Memory Analytics', date: '2025-03-20', description: 'Data context memory in Google Sheets', announcement: 'Google Workspace Update', category: 'Analytics Memory' },
                        { provider: 'Google', product: 'Drive Memory Indexing', date: '2025-04-15', description: 'File context memory in Google Drive', announcement: 'Google I/O 2025', category: 'Storage Memory' },
                        { provider: 'Google', product: 'Meet Memory Context', date: '2025-05-22', description: 'Meeting memory in Google Meet', announcement: 'Google Workspace Update', category: 'Video Memory' },
                        { provider: 'Google', product: 'Search Memory Personalization', date: '2025-06-18', description: 'Personalized search memory', announcement: 'Google I/O 2025', category: 'Search Memory' },
                        { provider: 'Google', product: 'Photos Memory Recognition', date: '2025-07-10', description: 'Visual memory in Google Photos', announcement: 'Google Photos Update', category: 'Visual Memory' },
                        { provider: 'Microsoft', product: 'Copilot Memory v2', date: '2025-01-08', description: 'Enhanced memory with 300K token capacity', announcement: 'Microsoft Build 2025', category: 'Productivity Memory' },
                        { provider: 'Microsoft', product: 'Word Memory Context', date: '2025-02-05', description: 'Document memory in Microsoft Word', announcement: 'Microsoft 365 Update', category: 'Document Memory' },
                        { provider: 'Microsoft', product: 'Excel Memory Analytics', date: '2025-03-12', description: 'Spreadsheet context memory', announcement: 'Microsoft 365 Update', category: 'Analytics Memory' },
                        { provider: 'Microsoft', product: 'PowerPoint Memory', date: '2025-04-08', description: 'Presentation context memory', announcement: 'Microsoft 365 Update', category: 'Presentation Memory' },
                        { provider: 'Microsoft', product: 'Outlook Memory Integration', date: '2025-05-15', description: 'Email memory in Outlook', announcement: 'Microsoft 365 Update', category: 'Email Memory' },
                        { provider: 'Microsoft', product: 'OneNote Memory Context', date: '2025-06-20', description: 'Note-taking memory in OneNote', announcement: 'Microsoft 365 Update', category: 'Note Memory' },
                        { provider: 'Microsoft', product: 'SharePoint Memory', date: '2025-07-10', description: 'Collaboration memory in SharePoint', announcement: 'Microsoft Ignite 2025', category: 'Collaboration Memory' },
                        { provider: 'Microsoft', product: 'Power Platform Memory', date: '2025-08-14', description: 'Low-code memory integration', announcement: 'Microsoft Power Platform', category: 'Platform Memory' },
                        { provider: 'OpenAI', product: 'GPT-4o Memory Expansion', date: '2025-01-20', description: 'Enhanced memory with 500K token capacity', announcement: 'OpenAI Developer Day 2025', category: 'Agent Memory' },
                        { provider: 'OpenAI', product: 'ChatGPT Memory Personalization', date: '2025-03-15', description: 'Personalized memory in ChatGPT', announcement: 'OpenAI Product Update', category: 'Conversational Memory' },
                        { provider: 'OpenAI', product: 'Assistant Memory API', date: '2025-05-22', description: 'Memory API for custom GPT assistants', announcement: 'OpenAI Platform Update', category: 'Agent Memory' },
                        { provider: 'OpenAI', product: 'Memory Export & Portability', date: '2025-07-18', description: 'Data portability for ChatGPT memory', announcement: 'OpenAI Developer Update', category: 'Memory Governance' },
                        { provider: 'Anthropic', product: 'Claude Memory v2', date: '2025-02-10', description: 'Enhanced memory with 300K tokens', announcement: 'Anthropic Product Launch', category: 'Conversational Memory' },
                        { provider: 'Anthropic', product: 'Claude Memory Personalization', date: '2025-04-25', description: 'Personalized memory for Claude users', announcement: 'Anthropic Platform Update', category: 'Conversational Memory' }
                    ]
                },
                agentFeatures: [
                    { provider: 'Google', q1: 3, q2: 5, q3: 7, q4: 4 },
                    { provider: 'Microsoft', q1: 2, q2: 6, q3: 5, q4: 8 },
                    { provider: 'OpenAI', q1: 4, q2: 6, q3: 5, q4: 6 },
                    { provider: 'Anthropic', q1: 2, q2: 3, q3: 4, q4: 4 }
                ],
                identityExpansions: {
                    Google: { workspace: 8, graph: 12, account: 6 },
                    Microsoft: { workspace: 10, graph: 9, account: 8 },
                    OpenAI: { workspace: 6, graph: 8, account: 7 },
                    Anthropic: { workspace: 4, graph: 5, account: 6 }
                },
                alerts: [
                    { type: 'spike', severity: 'high', title: 'Memory Release Spike', message: '3+ memory-related releases detected in Q1 2025', date: '2025-03-15' },
                    { type: 'convergence', severity: 'medium', title: 'Feature Convergence', message: 'Multiple providers launched similar agent features within 45 days', date: '2025-02-20' },
                    { type: 'identity', severity: 'high', title: 'Identity Creep Detected', message: 'New capabilities binding to Workspace/Graph contexts', date: '2025-04-15' }
                ]
            },
            memory: {
                providers: [
                    {
                        name: 'Google',
                        lockInIndex: 85,
                        opennessScore: 25,
                        recallDepth: 128000,
                        boundariesScore: 40,
                        crossAppReach: 12,
                        defaultOnRate: 85,
                        visibilityIndex: 30,
                        apps: ['Gmail', 'Docs', 'Classroom', 'Calendar', 'Keep', 'Drive', 'Sheets', 'Slides', 'Meet', 'Chat', 'Search', 'Photos']
                    },
                    {
                        name: 'Microsoft',
                        lockInIndex: 82,
                        opennessScore: 35,
                        recallDepth: 200000,
                        boundariesScore: 50,
                        crossAppReach: 15,
                        defaultOnRate: 90,
                        visibilityIndex: 35,
                        apps: ['Outlook', 'Word', 'Excel', 'PowerPoint', 'Teams', 'OneNote', 'OneDrive', 'SharePoint', 'Planner', 'To-Do', 'Calendar', 'Forms', 'Sway', 'Yammer', 'Stream']
                    },
                    {
                        name: 'OpenAI',
                        lockInIndex: 85,
                        opennessScore: 50,
                        recallDepth: 128000,
                        boundariesScore: 55,
                        crossAppReach: 8,
                        defaultOnRate: 90,
                        visibilityIndex: 45,
                        apps: ['ChatGPT', 'GPTs', 'API', 'Plugins', 'Assistants', 'DALL·E', 'Whisper', 'Code Interpreter']
                    },
                    {
                        name: 'Anthropic',
                        lockInIndex: 70,
                        opennessScore: 60,
                        recallDepth: 200000,
                        boundariesScore: 60,
                        crossAppReach: 6,
                        defaultOnRate: 75,
                        visibilityIndex: 50,
                        apps: ['Claude', 'API', 'Console', 'Workbench', 'Messaging', 'Tools']
                    }
                ],
                recallDepthHistory: [
                    { model: 'GPT-3.5', date: '2024-01', depth: 4096 },
                    { model: 'GPT-4', date: '2024-03', depth: 8192 },
                    { model: 'GPT-4 Turbo', date: '2024-09', depth: 128000 },
                    { model: 'Claude-2', date: '2024-02', depth: 100000 },
                    { model: 'Claude-3', date: '2024-10', depth: 200000 },
                    { model: 'Gemini Pro', date: '2024-04', depth: 32000 },
                    { model: 'Gemini Ultra', date: '2024-06', depth: 128000 }
                ],
                identityLockIn: [
                    { 
                        provider: 'Microsoft', 
                        percentage: 78, 
                        description: 'Copilot capabilities rely on Microsoft Graph identity',
                        details: 'Microsoft Graph identity system is deeply integrated with Copilot memory, enabling cross-app personalization but creating strong lock-in dependencies'
                    },
                    { 
                        provider: 'Google', 
                        percentage: 72, 
                        description: 'Gemini + Classroom integrations depend on Workspace identity',
                        details: 'Workspace identity is foundational for Gemini memory across Classroom and education tools, creating institutional dependency on Google identity ecosystem'
                    },
                    { 
                        provider: 'OpenAI', 
                        percentage: 40, 
                        description: 'Memory features tied to ChatGPT account/workspace',
                        details: 'ChatGPT account and workspace identities enable persistent memory across conversations and custom GPTs, with growing organizational identity integration'
                    },
                    { 
                        provider: 'Anthropic', 
                        percentage: 35, 
                        description: 'Tied to Claude organizational workspaces',
                        details: 'Claude organizational workspaces enable team-level memory and context sharing, with moderate identity binding compared to hyperscaler platforms'
                    }
                ],
                alerts: [
                    { type: 'default-on', severity: 'high', title: 'Memory Default-On Change', message: 'Microsoft changed memory to default-on for EDU accounts', date: '2025-05-01' },
                    { type: 'cross-app', severity: 'medium', title: 'New Cross-App Memory Integration', message: 'Google integrated Classroom memory with Workspace Graph', date: '2025-04-10' },
                    { type: 'recall-depth', severity: 'high', title: 'Major Recall Depth Increase', message: 'Claude-3 increased recall depth to 200K tokens', date: '2025-03-01' }
                ]
            },
            education: {
                providers: [
                    {
                        name: 'Google',
                        integrationScore: 92,
                        lmsIntegrations: ['Canvas', 'Schoology', 'Blackboard', 'Brightspace', 'Moodle'],
                        workflowCoverage: 88,
                        districtPenetration: 58,
                        agentWorkloads: ['Tutoring', 'Feedback', 'Grading', 'Lesson Planning', 'IEP Support'],
                        useCases: {
                            'AI Tutoring': 75,
                            'Automated Grading': 85,
                            'Real-time Feedback': 88,
                            'Instructional Planning': 80,
                            'Teacher Coaching': 70
                        },
                        memoryInEDU: true
                    },
                    {
                        name: 'Microsoft',
                        integrationScore: 87,
                        lmsIntegrations: ['Canvas', 'Schoology', 'Blackboard', 'Brightspace'],
                        workflowCoverage: 82,
                        districtPenetration: 27,
                        agentWorkloads: ['Feedback', 'Grading', 'Lesson Planning', 'Tutoring'],
                        useCases: {
                            'AI Tutoring': 70,
                            'Automated Grading': 80,
                            'Real-time Feedback': 82,
                            'Instructional Planning': 75,
                            'Teacher Coaching': 65
                        },
                        memoryInEDU: true
                    },
                    {
                        name: 'OpenAI',
                        integrationScore: 65,
                        lmsIntegrations: ['Canvas', 'Blackboard'],
                        workflowCoverage: 60,
                        districtPenetration: 12,
                        agentWorkloads: ['Tutoring', 'Feedback', 'Lesson Planning'],
                        useCases: {
                            'AI Tutoring': 75,
                            'Automated Grading': 55,
                            'Real-time Feedback': 60,
                            'Instructional Planning': 50,
                            'Teacher Coaching': 70
                        },
                        memoryInEDU: true
                    },
                    {
                        name: 'Anthropic',
                        integrationScore: 45,
                        lmsIntegrations: ['Canvas'],
                        workflowCoverage: 40,
                        districtPenetration: 3,
                        agentWorkloads: ['Tutoring', 'Feedback'],
                        useCases: {
                            'AI Tutoring': 60,
                            'Automated Grading': 40,
                            'Real-time Feedback': 45,
                            'Instructional Planning': 35,
                            'Teacher Coaching': 55
                        },
                        memoryInEDU: false
                    }
                ],
                ecosystemRisk: {
                    Google: 58,
                    Microsoft: 27,
                    OpenAI: 12,
                    Anthropic: 3
                },
                agentFutures: [
                    { category: 'Tutoring', providers: ['Google', 'Microsoft'], timeline: '2024-Q3', maturity: 'emerging' },
                    { category: 'Advising', providers: ['Google'], timeline: '2024-Q4', maturity: 'early' },
                    { category: 'IEP Support', providers: ['Google', 'Microsoft'], timeline: '2025-Q1', maturity: 'research' },
                    { category: 'Grading', providers: ['Google', 'Microsoft'], timeline: '2024-Q2', maturity: 'pilot' }
                ],
                alerts: [
                    { type: 'integration', severity: 'medium', title: 'New K-12 Integration Launched', message: 'Microsoft announced Teams for Education AI features', date: '2025-05-15' },
                    { type: 'adoption', severity: 'high', title: 'District Adoption Trend Spike', message: 'Google Workspace EDU adoption increased 15% this quarter', date: '2025-06-01' },
                    { type: 'memory-edu', severity: 'high', title: 'Memory Usage in EDU Workflows', message: 'Google Classroom now uses Graph memory for student context', date: '2025-04-20' }
                ]
            },
            opportunity: {
                providers: [
                    {
                        name: 'Google',
                        opennessScore: 25,
                        educationIntegration: 92,
                        opennessGap: 67,
                        infrastructureNeed: 85,
                        plpComplementarity: 15,
                        marketTiming: 20
                    },
                    {
                        name: 'Microsoft',
                        opennessScore: 35,
                        educationIntegration: 87,
                        opennessGap: 52,
                        infrastructureNeed: 75,
                        plpComplementarity: 25,
                        marketTiming: 30
                    },
                    {
                        name: 'PLP',
                        opennessScore: 95,
                        educationIntegration: 30,
                        opennessGap: -65,
                        infrastructureNeed: 80,
                        plpComplementarity: 100,
                        marketTiming: 85
                    }
                ],
                investmentCategories: [
                    {
                        category: 'Foundational Infrastructure',
                        items: ['Schemas', 'Routing', 'Identity'],
                        priority: 90,
                        timing: 'Immediate',
                        budget: 'High'
                    },
                    {
                        category: 'PLP-Aware Agents',
                        items: ['Tutoring', 'Advising', 'IEP Support'],
                        priority: 85,
                        timing: '2024-Q3',
                        budget: 'Medium'
                    },
                    {
                        category: 'Public-Good Datasets',
                        items: ['Benchmarks', 'Evaluation Sets'],
                        priority: 75,
                        timing: '2024-Q4',
                        budget: 'Low'
                    },
                    {
                        category: 'System Pilots',
                        items: ['District Pilots', 'State Pilots'],
                        priority: 80,
                        timing: '2025-Q1',
                        budget: 'High'
                    }
                ],
                riskGradient: [
                    { provider: 'Google', risk: 'high', color: '#e53e3e', educationDependency: 92 },
                    { provider: 'Microsoft', risk: 'high', color: '#e53e3e', educationDependency: 87 },
                    { provider: 'OpenAI', risk: 'medium', color: '#ed8936', educationDependency: 65 },
                    { provider: 'Anthropic', risk: 'low', color: '#48bb78', educationDependency: 45 },
                    { provider: 'PLP', risk: 'low', color: '#48bb78', educationDependency: 30 }
                ],
                alerts: [
                    { type: 'window', severity: 'info', title: 'Opportunity Window Opening', message: 'Lack of EDU memory product launches creates PLP alignment opportunity', date: '2025-06-15' },
                    { type: 'alignment', severity: 'medium', title: 'Ideal PLP Alignment Detected', message: 'Provider surfacing new API layer - integration timing optimal', date: '2025-05-20' },
                    { type: 'lock-in', severity: 'high', title: 'Rising Lock-In Risk', message: 'Google and Microsoft expanding default-on memory in EDU', date: '2025-06-01' }
                ]
            }
        };

        // Helper function to create collapsible rationale section
        function createCollapsibleRationale(container, htmlContent) {
            const rationale = container.appendChild(document.createElement('div'));
            rationale.className = 'chart-rationale';
            
            const header = rationale.appendChild(document.createElement('div'));
            header.className = 'chart-rationale-header';
            
            const titleDiv = header.appendChild(document.createElement('div'));
            titleDiv.className = 'chart-rationale-header-title';
            titleDiv.textContent = 'Why This Chart Matters';
            
            const controlDiv = header.appendChild(document.createElement('div'));
            controlDiv.className = 'chart-rationale-header-control';
            
            const icon = controlDiv.appendChild(document.createElement('span'));
            icon.className = 'chart-rationale-header-icon';
            icon.textContent = '▶';
            
            const text = controlDiv.appendChild(document.createElement('span'));
            text.textContent = 'Click to expand';
            
            const contentWrapper = rationale.appendChild(document.createElement('div'));
            contentWrapper.className = 'chart-rationale-content-wrapper';
            contentWrapper.innerHTML = htmlContent;
            
            header.onclick = function() {
                const isExpanded = contentWrapper.classList.contains('expanded');
                if (isExpanded) {
                    contentWrapper.classList.remove('expanded');
                    icon.textContent = '▶';
                    text.textContent = 'Click to expand';
                } else {
                    contentWrapper.classList.add('expanded');
                    icon.textContent = '▼';
                    text.textContent = 'Click to collapse';
                }
            };
            
            return rationale;
        }

        // Module navigation
        function showModule(moduleName) {
            // Hide all modules
            document.querySelectorAll('.dashboard-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active from all buttons
            document.querySelectorAll('.module-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected module
            document.getElementById(`module-${moduleName}`).classList.add('active');
            
            // Activate button
            event.target.classList.add('active');
            
            // Render module-specific content
            switch(moduleName) {
                case 'ecosystem':
                    renderEcosystemModule();
                    break;
                case 'memory':
                    renderMemoryModule();
                    break;
                case 'education':
                    renderEducationModule();
                    break;
            }
        }

        // Module 1: Ecosystem Moves
        function renderEcosystemModule() {
            updateEcosystemStats();
            renderEcosystemAlerts();
            renderMemoryGrowthChart();
            renderEcosystemTimeline();
            renderAgentVelocity();
        }

        function updateEcosystemStats() {
            const data = dashboardData.ecosystem;
            const memoryReleases = data.releases.filter(r => r.featureType === 'memory').length;
            const agentFeatures = data.releases.filter(r => r.featureType === 'agent').length;
            const identityExpansions = data.releases.filter(r => r.featureType === 'identity').length;
            const apiGrowth = data.releases.filter(r => r.featureType === 'api').length;
            const convergenceCount = data.alerts.filter(a => a.type === 'convergence').length;

            document.getElementById('ecosystemMemoryReleases').textContent = memoryReleases;
            document.getElementById('ecosystemAgentFeatures').textContent = agentFeatures;
            document.getElementById('ecosystemIdentityExpansions').textContent = identityExpansions;
            document.getElementById('ecosystemAPIGrowth').textContent = apiGrowth;
            document.getElementById('ecosystemConvergenceCount').textContent = convergenceCount;
        }

        function renderEcosystemAlerts() {
            const container = document.getElementById('ecosystemAlerts');
            const alerts = dashboardData.ecosystem.alerts;
            
            container.innerHTML = '<div style="font-weight: 700; color: #e2e8f0; margin-bottom: 15px;">Smart Alerts</div>';
            
            alerts.forEach(alert => {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert-item ${alert.severity === 'high' ? '' : alert.severity === 'medium' ? 'warning' : 'info'}`;
                alertDiv.innerHTML = `
                    <div class="alert-title">${alert.title}</div>
                    <div class="alert-message">${alert.message} - ${alert.date}</div>
                `;
                container.appendChild(alertDiv);
            });
        }

        function renderMemoryGrowthChart() {
            const container = document.getElementById('ecosystemMemoryGrowthChart');
            const width = container.parentElement.clientWidth - 50;
            const height = 450;
            const margin = { top: 40, right: 30, bottom: 80, left: 80 };

            container.innerHTML = '';

            // Create tooltip
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const data = dashboardData.ecosystem.memoryGrowthByYear;
            const years = [2023, 2024, 2025];
            const providers = ['Google', 'Microsoft', 'OpenAI', 'Anthropic'];
            const colorScale = d3.scaleOrdinal()
                .domain(providers)
                .range(['#4285f4', '#00a4ef', '#ff6b35', '#d4a574']);

            // Prepare data for grouped bars
            const barData = years.map(year => ({
                year,
                total: data[year].total,
                providers: providers.map(provider => ({
                    provider,
                    value: data[year].byProvider[provider] || 0
                }))
            }));

            const xScale = d3.scaleBand()
                .domain(years)
                .range([0, chartWidth])
                .padding(0.2);

            const maxValue = d3.max(barData, d => d.total);
            const yScale = d3.scaleLinear()
                .domain([0, maxValue * 1.15])
                .range([chartHeight, 0]);

            // Grouped bars
            const barWidth = xScale.bandwidth() / providers.length;

            barData.forEach((yearData, yearIdx) => {
                yearData.providers.forEach((providerData, pIdx) => {
                    const x = xScale(yearData.year) + pIdx * barWidth;
                    const barHeight = chartHeight - yScale(providerData.value);
                    
                    const bar = g.append('rect')
                        .attr('x', x)
                        .attr('y', yScale(providerData.value))
                        .attr('width', barWidth - 2)
                        .attr('height', barHeight)
                        .attr('fill', colorScale(providerData.provider))
                        .attr('rx', 4)
                        .attr('cursor', 'pointer')
                        .style('opacity', 0.85);

                    // Value labels on bars
                    if (providerData.value > 0) {
                        g.append('text')
                            .attr('x', x + barWidth / 2)
                            .attr('y', yScale(providerData.value) - 5)
                            .attr('text-anchor', 'middle')
                            .attr('fill', '#e2e8f0')
                            .attr('font-size', '10px')
                            .attr('font-weight', '600')
                            .text(providerData.value);
                    }

                    // Tooltip
                    bar.on('mouseover', function(event) {
                        const growth2023to2025 = yearData.year === 2025 ? 
                            ((data[2025].byProvider[providerData.provider] - data[2023].byProvider[providerData.provider]) / Math.max(data[2023].byProvider[providerData.provider], 1) * 100) : 0;
                        
                        tooltip.transition().duration(200).style('opacity', 1);
                        tooltip.html(`
                            <div class="tooltip-title">${providerData.provider} - ${yearData.year}</div>
                            <div class="tooltip-item"><strong>Memory Releases:</strong> ${providerData.value}</div>
                            <div class="tooltip-item"><strong>Year Total:</strong> ${yearData.total} releases</div>
                            ${yearData.year === 2025 ? `<div class="tooltip-item"><strong>Growth (2023→2025):</strong> ${growth2023to2025 > 0 ? '+' : ''}${growth2023to2025.toFixed(0)}%</div>` : ''}
                            ${yearData.year === 2023 ? `<div class="tooltip-item" style="font-size: 0.8rem; color: #667eea; margin-top: 8px;">Baseline year - foundation for memory ecosystem</div>` : ''}
                            ${yearData.year === 2025 ? `<div class="tooltip-item" style="font-size: 0.8rem; color: #e53e3e; margin-top: 8px;">⚠ 450% total growth indicates accelerating lock-in risk</div>` : ''}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                        
                        bar.style('opacity', 1);
                    })
                    .on('mouseout', function() {
                        tooltip.transition().duration(200).style('opacity', 0);
                        bar.style('opacity', 0.85);
                    });
                });
            });

            // Total labels above bars
            barData.forEach(yearData => {
                const x = xScale(yearData.year) + xScale.bandwidth() / 2;
                g.append('text')
                    .attr('x', x)
                    .attr('y', yScale(yearData.total) - 10)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#e2e8f0')
                    .attr('font-size', '14px')
                    .attr('font-weight', '700')
                    .text(yearData.total);
            });

            // Growth annotation
            const growth2023to2025 = ((data[2025].total - data[2023].total) / data[2023].total * 100);
            g.append('line')
                .attr('x1', xScale(2023))
                .attr('y1', yScale(data[2023].total) - 25)
                .attr('x2', xScale(2025))
                .attr('y2', yScale(data[2025].total) - 25)
                .attr('stroke', '#48bb78')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            g.append('text')
                .attr('x', (xScale(2023) + xScale(2025)) / 2)
                .attr('y', yScale(data[2025].total) - 35)
                .attr('text-anchor', 'middle')
                .attr('fill', '#48bb78')
                .attr('font-size', '13px')
                .attr('font-weight', '700')
                .text(`+${growth2023to2025}% Growth`);

            // Highlight 2024-2025 jump
            const jump2024to2025 = ((data[2025].total - data[2024].total) / data[2024].total * 100);
            g.append('rect')
                .attr('x', xScale(2024) - 5)
                .attr('y', 0)
                .attr('width', xScale.bandwidth() + 10)
                .attr('height', chartHeight)
                .attr('fill', 'rgba(102, 126, 234, 0.05)')
                .attr('stroke', '#667eea')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '3,3')
                .style('pointer-events', 'none');

            g.append('text')
                .attr('x', xScale(2025) + xScale.bandwidth() / 2)
                .attr('y', chartHeight - 20)
                .attr('text-anchor', 'middle')
                .attr('fill', '#ffffff')
                .attr('font-size', '11px')
                .attr('font-weight', '600')
                .text(`83% jump from 2024`);

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '12px');

            g.append('g')
                .call(d3.axisLeft(yScale).ticks(8))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px');

            // Axis labels
            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + 50)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Year');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -60)
                .attr('x', -chartHeight / 2)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Number of Memory-Related Releases');

            // Legend
            const legend = container.appendChild(document.createElement('div'));
            legend.className = 'chart-legend';
            providers.forEach(provider => {
                const total = data[2023].byProvider[provider] + data[2024].byProvider[provider] + data[2025].byProvider[provider];
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${colorScale(provider)}"></div>
                    <div class="legend-text">${provider} (${total} total)</div>
                `;
                legend.appendChild(item);
            });

            // Info panel
            const infoPanel = container.appendChild(document.createElement('div'));
            infoPanel.className = 'chart-info';
            infoPanel.innerHTML = `
                <strong>Chart Details:</strong> Growth of memory-related product releases by provider from 2023 to 2025. 
                Total releases: <strong>${data[2023].total} in 2023</strong> → <strong>${data[2024].total} in 2024</strong> → <strong>${data[2025].total} in 2025</strong>. 
                This represents a <strong>${growth2023to2025}% increase</strong> from 2023 to 2025, indicating accelerating investment in memory infrastructure.
            `;

            // Product Breakdown Section (Collapsible)
            const breakdownSection = container.appendChild(document.createElement('div'));
            breakdownSection.style.cssText = 'margin-top: 20px; background: #1a202c; border: 2px solid #4a5568; border-radius: 12px; padding: 15px;';
            
            const breakdownHeader = breakdownSection.appendChild(document.createElement('div'));
            breakdownHeader.style.cssText = 'cursor: pointer; user-select: none; display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: #2d3748; border-radius: 6px; margin-bottom: 0; transition: all 0.3s ease; border: 1px solid #4a5568;';
            breakdownHeader.onmouseenter = function() {
                breakdownHeader.style.background = '#3d4758';
                breakdownHeader.style.borderColor = '#667eea';
            };
            breakdownHeader.onmouseleave = function() {
                breakdownHeader.style.background = '#2d3748';
                breakdownHeader.style.borderColor = '#4a5568';
            };
            breakdownHeader.onclick = function() {
                const isCollapsed = breakdownContent.style.display === 'none';
                breakdownContent.style.display = isCollapsed ? 'block' : 'none';
                expandIcon.textContent = isCollapsed ? '▼' : '▶';
                expandText.textContent = isCollapsed ? 'Click to collapse' : 'Click to expand';
                breakdownHeader.style.marginBottom = isCollapsed ? '15px' : '0';
            };
            
            const breakdownTitle = breakdownHeader.appendChild(document.createElement('div'));
            breakdownTitle.style.cssText = 'font-size: 0.95rem; font-weight: 700; color: #667eea; display: flex; align-items: center; gap: 8px;';
            breakdownTitle.innerHTML = '<span>Product Breakdown: How Each Memory Product is Counted</span>';
            
            const expandControl = breakdownHeader.appendChild(document.createElement('div'));
            expandControl.style.cssText = 'display: flex; align-items: center; gap: 8px; font-size: 0.75rem; color: #a0aec0;';
            
            const expandIcon = expandControl.appendChild(document.createElement('span'));
            expandIcon.style.cssText = 'font-size: 0.9rem; color: #667eea; font-weight: 700;';
            expandIcon.textContent = '▶';
            
            const expandText = expandControl.appendChild(document.createElement('span'));
            expandText.textContent = 'Click to expand';
            
            const breakdownContent = breakdownSection.appendChild(document.createElement('div'));
            breakdownContent.style.cssText = 'display: none;'; // Collapsed by default

            const productsData = dashboardData.ecosystem.memoryProductsByYear;
            const breakdownYears = [2023, 2024, 2025];

            breakdownYears.forEach(year => {
                const yearSection = breakdownContent.appendChild(document.createElement('div'));
                yearSection.style.cssText = 'margin-bottom: 18px;';
                
                const yearHeader = yearSection.appendChild(document.createElement('div'));
                yearHeader.style.cssText = 'font-size: 0.9rem; font-weight: 700; color: #e2e8f0; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;';
                yearHeader.innerHTML = `
                    <span>${year}</span>
                    <span style="font-size: 0.75rem; color: #667eea; font-weight: 600;">(${productsData[year].length} products)</span>
                `;

                // Group by provider
                const byProvider = {};
                productsData[year].forEach(product => {
                    if (!byProvider[product.provider]) {
                        byProvider[product.provider] = [];
                    }
                    byProvider[product.provider].push(product);
                });

                Object.keys(byProvider).forEach(provider => {
                    const providerSection = yearSection.appendChild(document.createElement('div'));
                    providerSection.style.cssText = 'margin-bottom: 12px; padding: 10px; background: #2d3748; border-radius: 6px; border-left: 3px solid ' + colorScale(provider) + ';';
                    
                    const providerHeader = providerSection.appendChild(document.createElement('div'));
                    providerHeader.style.cssText = 'font-weight: 700; color: #e2e8f0; margin-bottom: 8px; font-size: 0.85rem;';
                    providerHeader.textContent = `${provider} (${byProvider[provider].length} product${byProvider[provider].length > 1 ? 's' : ''})`;

                    byProvider[provider].forEach((product, idx) => {
                        const productDiv = providerSection.appendChild(document.createElement('div'));
                        productDiv.style.cssText = 'padding: 8px; margin-bottom: 6px; background: #1a202c; border-radius: 4px; border: 1px solid #4a5568;';
                        
                        const productName = productDiv.appendChild(document.createElement('div'));
                        productName.style.cssText = 'font-weight: 700; color: #e2e8f0; margin-bottom: 4px; font-size: 0.8rem;';
                        productName.textContent = `${idx + 1}. ${product.product}`;

                        const productDetails = productDiv.appendChild(document.createElement('div'));
                        productDetails.style.cssText = 'font-size: 0.7rem; color: #a0aec0; line-height: 1.4;';
                        productDetails.innerHTML = `
                            <div style="margin-bottom: 2px;"><strong>Date:</strong> ${new Date(product.date).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' })}</div>
                            <div style="margin-bottom: 2px;"><strong>Description:</strong> ${product.description}</div>
                            <div style="margin-bottom: 2px;"><strong>Announcement:</strong> ${product.announcement}</div>
                            <div><strong>Category:</strong> <span style="color: #667eea;">${product.category}</span></div>
                        `;
                    });
                });
            });

            // Methodology note
            const methodologyNote = breakdownContent.appendChild(document.createElement('div'));
            methodologyNote.style.cssText = 'margin-top: 15px; padding-top: 12px; border-top: 1px solid #4a5568; font-size: 0.75rem; color: #a0aec0; line-height: 1.5;';
            methodologyNote.innerHTML = `
                <strong style="color: #667eea;">Counting Methodology:</strong> Each product is counted as a distinct memory-related release when it:
                <ul style="margin-top: 6px; padding-left: 18px; list-style: disc; font-size: 0.75rem;">
                    <li>Introduces new memory capabilities (APIs, storage, retrieval)</li>
                    <li>Expands memory capacity or functionality in existing products</li>
                    <li>Integrates memory into new application contexts (email, documents, collaboration)</li>
                    <li>Adds memory governance or portability features</li>
                </ul>
                <p style="margin-top: 8px; font-style: italic; font-size: 0.75rem;">Minor updates, bug fixes, and feature enhancements that don't add new memory capabilities are not counted. Each product represents a distinct announcement or release event.</p>
            `;

        }

        function renderEcosystemTimeline() {
            const container = document.getElementById('ecosystemTimelineChart');
            const width = container.parentElement.clientWidth - 50;
            const height = 450;
            const margin = { top: 40, right: 30, bottom: 80, left: 80 };

            container.innerHTML = '';

            // Create tooltip
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const providers = ['Google', 'Microsoft', 'OpenAI', 'Anthropic'];
            const featureTypes = ['memory', 'agent', 'identity', 'api', 'safety'];
            const featureLabels = { memory: 'Memory', agent: 'Agentic AI', identity: 'Identity', api: 'API Surface', safety: 'Safety & Governance' };
            const colorScale = d3.scaleOrdinal()
                .domain(providers)
                .range(['#4285f4', '#00a4ef', '#ff6b35', '#d4a574']);

            // Process releases with cumulative counts
            const releases = dashboardData.ecosystem.releases.sort((a, b) => new Date(a.date) - new Date(b.date));
            const dateGroups = {};
            
            releases.forEach(release => {
                const date = new Date(release.date);
                const key = `${release.provider}_${release.featureType}`;
                if (!dateGroups[key]) {
                    dateGroups[key] = [];
                }
                dateGroups[key].push({ date, release, count: dateGroups[key].length + 1 });
            });

            // Date range (clamped to 2024–2025)
            const dates = releases.map(r => new Date(r.date));
            const domainStart = new Date('2024-01-01');
            const domainEnd = new Date('2025-12-31');
            const xScale = d3.scaleTime()
                .domain([domainStart, domainEnd])
                .range([0, chartWidth]);

            // Create y positions for each provider/feature combination
            let yPos = 0;
            const yPositions = {};
            providers.forEach(provider => {
                featureTypes.forEach(type => {
                    const key = `${provider}_${type}`;
                    if (dateGroups[key]) {
                        yPositions[key] = yPos;
                        yPos += 1;
                    }
                });
            });

            const maxY = yPos;
            const yScale = d3.scaleLinear()
                .domain([0, maxY])
                .range([chartHeight, 0]);

            // Acceleration windows
            const accelerationWindows = [
                { start: new Date('2024-01-01'), end: new Date('2024-03-31'), label: 'Q1 2024 Acceleration', providers: ['Google', 'Microsoft'] },
                { start: new Date('2024-04-01'), end: new Date('2024-06-30'), label: 'Q2 2024 Surge', providers: ['Google', 'Microsoft'] },
                { start: new Date('2024-07-01'), end: new Date('2025-10-31'), label: 'Progress Window (Jul 2024 – Oct 2025)', providers: providers }
            ];

            // Draw acceleration windows
            accelerationWindows.forEach(window => {
                const x1 = xScale(window.start);
                const x2 = xScale(window.end);
                g.append('rect')
                    .attr('x', x1)
                    .attr('y', 0)
                    .attr('width', x2 - x1)
                    .attr('height', chartHeight)
                    .attr('fill', 'rgba(102, 126, 234, 0.1)')
                    .attr('stroke', '#667eea')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '3,3');

                g.append('text')
                    .attr('x', (x1 + x2) / 2)
                    .attr('y', 10)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#667eea')
                    .attr('font-size', '11px')
                    .attr('font-weight', '600')
                    .text(window.label);
            });

            // Draw lines and points
            Object.keys(dateGroups).forEach(key => {
                const data = dateGroups[key];
                const [provider, featureType] = key.split('_');
                const y = yScale(yPositions[key]);

                // Line
                const line = d3.line()
                    .x(d => xScale(d.date))
                    .y(y)
                    .curve(d3.curveMonotoneX);

                g.append('path')
                    .datum(data.map(d => ({ date: d.date, y: y })))
                    .attr('fill', 'none')
                    .attr('stroke', colorScale(provider))
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.7)
                    .attr('d', line);

                // Points with tooltips
                data.forEach(d => {
                    const circle = g.append('circle')
                        .attr('cx', xScale(d.date))
                        .attr('cy', y)
                        .attr('r', 6)
                        .attr('fill', colorScale(provider))
                        .attr('stroke', '#e2e8f0')
                        .attr('stroke-width', 2)
                        .attr('cursor', 'pointer')
                        .style('opacity', 0.9);

                    circle.on('mouseover', function(event) {
                        tooltip.transition().duration(200).style('opacity', 1);
                        tooltip.html(`
                            <div class="tooltip-title">${d.release.feature}</div>
                            <div class="tooltip-item"><strong>Provider:</strong> ${provider}</div>
                            <div class="tooltip-item"><strong>Type:</strong> ${featureLabels[featureType] || featureType}</div>
                            <div class="tooltip-item"><strong>Date:</strong> ${d3.timeFormat('%b %d, %Y')(d.date)}</div>
                            <div class="tooltip-item"><strong>Description:</strong> ${d.release.description}</div>
                            ${d.release.details ? `<div class="tooltip-item" style="margin-top: 8px; font-style: italic;">${d.release.details}</div>` : ''}
                            ${d.release.tokens > 0 ? `<div class="tooltip-item"><strong>Memory Capacity:</strong> ${(d.release.tokens / 1000).toFixed(0)}K tokens</div>` : ''}
                            ${d.release.adoptionRate ? `<div class="tooltip-item"><strong>Adoption Rate:</strong> ${d.release.adoptionRate}%</div>` : ''}
                            ${d.release.apiEndpoints ? `<div class="tooltip-item"><strong>API Endpoints:</strong> ${d.release.apiEndpoints}</div>` : ''}
                            ${d.release.linkedFeatures ? `<div class="tooltip-item"><strong>Linked Features:</strong> ${d.release.linkedFeatures.join(', ')}</div>` : ''}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                        
                        circle.attr('r', 8).style('opacity', 1);
                    })
                    .on('mouseout', function() {
                        tooltip.transition().duration(200).style('opacity', 0);
                        circle.attr('r', 6).style('opacity', 0.9);
                    });
                });
            });

            // Progress distribution summary for Jul 2024 – Oct 2025
            const progressStart = new Date('2024-07-01');
            const progressEnd = new Date('2025-10-31');
            const progressCounts = {};
            providers.forEach(p => { progressCounts[p] = 0; });

            // Collect all events within the progress window for rationale
            const progressWindowEvents = [];
            releases.forEach(r => {
                const d = new Date(r.date);
                if (d >= progressStart && d <= progressEnd && progressCounts.hasOwnProperty(r.provider)) {
                    progressCounts[r.provider] += 1;
                    progressWindowEvents.push(r);
                }
            });

            // Sort events by date
            progressWindowEvents.sort((a, b) => new Date(a.date) - new Date(b.date));

            const progressSummary = providers.map(p => `${p}: ${progressCounts[p]} releases`).join(' • ');

            // Y-axis labels
            Object.keys(yPositions).forEach(key => {
                const [provider, featureType] = key.split('_');
                const y = yScale(yPositions[key]);
                g.append('text')
                    .attr('x', -10)
                    .attr('y', y)
                    .attr('text-anchor', 'end')
                    .attr('fill', '#a0aec0')
                    .attr('font-size', '10px')
                    .attr('alignment-baseline', 'middle')
                    .text(`${provider.substring(0, 3)} ${featureType.charAt(0).toUpperCase()}`);
            });

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale).ticks(8).tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end');

            // Axis labels
            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + 60)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Timeline (2024)');

            // Legend
            const legend = container.appendChild(document.createElement('div'));
            legend.className = 'chart-legend';
            providers.forEach(provider => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${colorScale(provider)}"></div>
                    <div class="legend-text">${provider}</div>
                `;
                legend.appendChild(item);
            });

            // Info panel
            const infoPanel = container.appendChild(document.createElement('div'));
            infoPanel.className = 'chart-info';
            infoPanel.innerHTML = `
                <strong>Chart Details:</strong> This timeline tracks memory-related, agentic AI, identity, API, and safety releases across major hyperscalers.
                Acceleration windows (shaded areas) indicate periods of concentrated product launches. Hover over data points for detailed release information.
                The chart shows ${releases.length} total releases from ${providers.length} providers across ${featureTypes.length} feature categories.
            `;

            // Build events list HTML for rationale
            let eventsListHTML = '';
            if (progressWindowEvents.length > 0) {
                eventsListHTML = '<div style="margin-top: 15px;"><strong style="color: #667eea; display: block; margin-bottom: 10px;">Progress Window Events (Jul 2024 – Oct 2025):</strong>';
                eventsListHTML += `<p style="margin-bottom: 10px; font-size: 0.9rem;">Distribution: ${progressSummary}</p>`;
                eventsListHTML += '<div style="max-height: 400px; overflow-y: auto; padding: 10px; background: rgba(45, 55, 72, 0.5); border-radius: 6px; margin-top: 10px;">';
                progressWindowEvents.forEach(event => {
                    const eventDate = d3.timeFormat('%b %d, %Y')(new Date(event.date));
                    eventsListHTML += `
                        <div style="margin-bottom: 12px; padding: 10px; background: rgba(102, 126, 234, 0.1); border-left: 3px solid ${colorScale(event.provider)}; border-radius: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 6px;">
                                <strong style="color: ${colorScale(event.provider)}; font-size: 0.9rem;">${event.provider}</strong>
                                <span style="color: #a0aec0; font-size: 0.85rem;">${eventDate}</span>
                            </div>
                            <div style="color: #e2e8f0; font-size: 0.9rem; font-weight: 600; margin-bottom: 4px;">${event.feature}</div>
                            <div style="color: #cbd5e0; font-size: 0.85rem; margin-bottom: 4px;">
                                <span style="background: rgba(102, 126, 234, 0.2); padding: 2px 6px; border-radius: 3px; font-size: 0.75rem;">${featureLabels[event.featureType] || event.featureType}</span>
                            </div>
                            <div style="color: #a0aec0; font-size: 0.85rem; line-height: 1.5;">${event.description}</div>
                            ${event.details ? `<div style="color: #718096; font-size: 0.8rem; margin-top: 4px; font-style: italic;">${event.details}</div>` : ''}
                        </div>
                    `;
                });
                eventsListHTML += '</div></div>';
            }

            // Rationale section
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p>The Memory Release Timeline is the foundational view for understanding competitive dynamics in AI memory infrastructure. By tracking when and how often hyperscalers release memory-related features, we can identify:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Strategic timing patterns:</strong> When providers accelerate launches (e.g., Q1 2024) signals strategic priorities and competitive responses</li>
                        <li><strong>Feature convergence windows:</strong> When multiple providers launch similar capabilities within 45 days indicates market maturity and strategic alignment</li>
                        <li><strong>Identity creep velocity:</strong> How rapidly identity-linked capabilities expand reveals lock-in strategies</li>
                        <li><strong>Investment windows:</strong> Periods between major releases create opportunities for PLP to establish market presence</li>
                    </ul>
                    ${eventsListHTML}
                </div>
                <div class="chart-rationale-section">
                    <strong>How to Interpret:</strong>
                    <p>Acceleration windows (shaded areas) indicate periods of intense competition. Multiple data points from different providers in a short timeframe suggest convergence risk — when platforms become functionally indistinguishable and lock-in accelerates. Convergence events within 45 days are particularly significant as they signal market maturity.</p>
                </div>
                <div class="chart-rationale-section">
                    <strong>Strategic Actions:</strong>
                    <ul class="chart-rationale-list">
                        <li>Monitor Q1 acceleration patterns annually to anticipate competitive moves</li>
                        <li>Use convergence alerts to identify windows for PLP differentiation</li>
                        <li>Track identity expansion separately — it's the strongest lock-in signal</li>
                    </ul>
                </div>
            `);
        }

        function renderAgentVelocity() {
            const container = document.getElementById('ecosystemAgentVelocityChart');
            const width = container.parentElement.clientWidth - 50;
            const height = 450;
            const margin = { top: 40, right: 30, bottom: 80, left: 70 };

            container.innerHTML = '';

            // Create tooltip
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const data = dashboardData.ecosystem.agentFeatures;
            const quarters = ['Q1', 'Q2', 'Q3', 'Q4'];
            const providers = data.map(d => d.provider);
            
            // Calculate trends
            const trends = data.map(d => {
                const values = [d.q1, d.q2, d.q3, d.q4];
                const total = values.reduce((a, b) => a + b, 0);
                const avg = total / values.length;
                const trend = d.q4 > d.q1 ? 'increasing' : d.q4 < d.q1 ? 'decreasing' : 'stable';
                const growth = ((d.q4 - d.q1) / Math.max(d.q1, 1)) * 100;
                return { provider: d.provider, trend, growth, total, avg };
            });

            const xScale = d3.scaleBand()
                .domain(quarters)
                .range([0, chartWidth])
                .padding(0.2);

            const maxValue = d3.max(data, d => Math.max(d.q1, d.q2, d.q3, d.q4));
            const yScale = d3.scaleLinear()
                .domain([0, maxValue * 1.1])
                .range([chartHeight, 0]);

            const colorScale = d3.scaleOrdinal()
                .domain(providers)
                .range(['#4285f4', '#00a4ef', '#ff6b35', '#d4a574']);

            // Grouped bars
            const barWidth = xScale.bandwidth() / providers.length;

            quarters.forEach((quarter, qIdx) => {
                providers.forEach((provider, pIdx) => {
                    const value = data[pIdx][`q${qIdx + 1}`];
                    const x = xScale(quarter) + pIdx * barWidth;
                    const barHeight = chartHeight - yScale(value);
                    
                    const bar = g.append('rect')
                        .attr('x', x)
                        .attr('y', yScale(value))
                        .attr('width', barWidth - 2)
                        .attr('height', barHeight)
                        .attr('fill', colorScale(provider))
                        .attr('rx', 4)
                        .attr('cursor', 'pointer')
                        .style('opacity', 0.8);

                    // Value label
                    if (value > 0) {
                        g.append('text')
                            .attr('x', x + barWidth / 2)
                            .attr('y', yScale(value) - 5)
                            .attr('text-anchor', 'middle')
                            .attr('fill', '#e2e8f0')
                            .attr('font-size', '11px')
                            .attr('font-weight', '600')
                            .text(value);
                    }

                    // Tooltip
                    bar.on('mouseover', function(event) {
                        const trend = trends[pIdx];
                        tooltip.transition().duration(200).style('opacity', 1);
                        tooltip.html(`
                            <div class="tooltip-title">${provider} - ${quarter} 2024</div>
                            <div class="tooltip-item"><strong>Agent Features:</strong> ${value}</div>
                            <div class="tooltip-item"><strong>Quarterly Total:</strong> ${trend.total} features</div>
                            <div class="tooltip-item"><strong>Average per Quarter:</strong> ${trend.avg.toFixed(1)}</div>
                            <div class="tooltip-item"><strong>Trend:</strong> <span style="color: ${trend.trend === 'increasing' ? '#48bb78' : trend.trend === 'decreasing' ? '#e53e3e' : '#a0aec0'}">${trend.trend}</span></div>
                            <div class="tooltip-item"><strong>Growth (Q1→Q4):</strong> ${trend.growth > 0 ? '+' : ''}${trend.growth.toFixed(0)}%</div>
                            <div class="tooltip-item" style="margin-top: 8px; font-size: 0.8rem; color: #667eea;">
                                ${trend.trend === 'increasing' ? '↗ Strategic prioritization increasing' : 
                                  trend.trend === 'decreasing' ? '↘ Feature development slowing' : 
                                  '→ Steady development pace'}
                            </div>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                        
                        bar.style('opacity', 1);
                    })
                    .on('mouseout', function() {
                        tooltip.transition().duration(200).style('opacity', 0);
                        bar.style('opacity', 0.8);
                    });
                });
            });

            // Add trend lines for each provider
            providers.forEach((provider, pIdx) => {
                const trendData = quarters.map((q, qIdx) => ({
                    quarter: q,
                    value: data[pIdx][`q${qIdx + 1}`],
                    x: xScale(q) + xScale.bandwidth() / 2
                }));

                const line = d3.line()
                    .x(d => d.x)
                    .y(d => yScale(d.value))
                    .curve(d3.curveMonotoneX);

                g.append('path')
                    .datum(trendData)
                    .attr('fill', 'none')
                    .attr('stroke', colorScale(provider))
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '3,3')
                    .attr('opacity', 0.4)
                    .attr('d', line);
            });

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '12px');

            g.append('g')
                .call(d3.axisLeft(yScale).ticks(8))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px');

            // Axis labels
            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + 50)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Quarter (2024)');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -50)
                .attr('x', -chartHeight / 2)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Number of Agent Features');

            // Legend
            const legend = container.appendChild(document.createElement('div'));
            legend.className = 'chart-legend';
            providers.forEach(provider => {
                const trend = trends.find(t => t.provider === provider);
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${colorScale(provider)}"></div>
                    <div class="legend-text">${provider} (${trend.trend === 'increasing' ? '↗' : trend.trend === 'decreasing' ? '↘' : '→'} ${trend.total} total)</div>
                `;
                legend.appendChild(item);
            });

            // Info panel
            const infoPanel = container.appendChild(document.createElement('div'));
            infoPanel.className = 'chart-info';
            const topProvider = trends.reduce((a, b) => b.total > a.total ? b : a);
            infoPanel.innerHTML = `
                <strong>Chart Details:</strong> Agent feature velocity by provider and quarter. Trend lines (dashed) show development trajectory.
                Hover over bars for detailed metrics. <strong>${topProvider.provider}</strong> leads with ${topProvider.total} total agent features in 2024.
                This chart helps detect strategic prioritization shifts and competitive positioning.
            `;

            // Rationale section
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p>Agent Feature Velocity reveals where hyperscalers are placing strategic bets. The number of agent-related features launched per quarter indicates:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Resource allocation:</strong> Providers investing heavily in agent infrastructure are betting on AI-driven workflows as the future</li>
                        <li><strong>Market positioning:</strong> Rapid acceleration in agent features signals a shift from infrastructure to application-layer competition</li>
                        <li><strong>Lock-in strategies:</strong> Agent features often depend on memory layers, creating compound lock-in effects</li>
                        <li><strong>Competitive gaps:</strong> Providers with slower velocity may have different strategies or resource constraints</li>
                    </ul>
                </div>
                <div class="chart-rationale-section">
                    <strong>How to Interpret:</strong>
                    <p>Trend lines (dashed) show development trajectory. Increasing trends indicate growing strategic importance. Convergence in feature counts across providers suggests commoditization risk. Providers with consistently high velocity are likely building for market dominance, while those with increasing velocity may be catching up.</p>
                </div>
                <div class="chart-rationale-section">
                    <strong>Strategic Actions:</strong>
                    <ul class="chart-rationale-list">
                        <li>Identify providers with increasing velocity as primary competitors for PLP positioning</li>
                        <li>Use velocity trends to anticipate future feature gaps where PLP can differentiate</li>
                        <li>Track whether agent features depend on closed memory systems — this compounds lock-in risk</li>
                    </ul>
                </div>
            `);
        }

        function renderIdentityRadar() {
            const container = document.getElementById('ecosystemIdentityRadarChart');
            const width = container.parentElement.clientWidth - 50;
            const height = 500;
            const margin = { top: 40, right: 40, bottom: 40, left: 40 };

            container.innerHTML = '';

            // Create tooltip
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 60;

            const dimensions = ['Workspace', 'Graph', 'Account', 'Cross-App', 'Privacy Controls'];
            const data = dashboardData.ecosystem.identityExpansions;
            const providers = Object.keys(data);

            const colorScale = d3.scaleOrdinal()
                .domain(providers)
                .range(['#4285f4', '#00a4ef', '#ff6b35', '#d4a574']);

            // Map dimensions to data keys
            const dimensionMap = {
                'Workspace': 'workspace',
                'Graph': 'graph',
                'Account': 'account',
                'Cross-App': 'workspace', // Using workspace as proxy
                'Privacy Controls': 'account' // Using account as proxy
            };

            const angleScale = d3.scalePoint()
                .domain(dimensions)
                .range([0, 2 * Math.PI]);

            const rScale = d3.scaleLinear()
                .domain([0, 15])
                .range([0, radius]);

            // Draw grid circles
            for (let i = 1; i <= 3; i++) {
                svg.append('circle')
                    .attr('cx', centerX)
                    .attr('cy', centerY)
                    .attr('r', (radius / 3) * i)
                    .attr('fill', 'none')
                    .attr('stroke', '#4a5568')
                    .attr('stroke-width', 1)
                    .attr('opacity', 0.3);

                svg.append('text')
                    .attr('x', centerX)
                    .attr('y', centerY - (radius / 3) * i + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#a0aec0')
                    .attr('font-size', '10px')
                    .text((i * 5).toString());
            }

            // Draw dimension axes
            dimensions.forEach((dimension, i) => {
                const angle = angleScale(dimension);
                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;

                svg.append('line')
                    .attr('x1', centerX)
                    .attr('y1', centerY)
                    .attr('x2', x1)
                    .attr('y2', y1)
                    .attr('stroke', '#4a5568')
                    .attr('stroke-width', 1)
                    .attr('opacity', 0.3);

                // Dimension labels
                const labelX = centerX + Math.cos(angle) * (radius + 30);
                const labelY = centerY + Math.sin(angle) * (radius + 30);
                svg.append('text')
                    .attr('x', labelX)
                    .attr('y', labelY)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#e2e8f0')
                    .attr('font-size', '12px')
                    .attr('font-weight', '600')
                    .text(dimension);
            });

            // Draw radar for each provider
            providers.forEach((provider, pIdx) => {
                const providerData = data[provider];
                const points = dimensions.map(dim => {
                    const key = dimensionMap[dim];
                    const value = providerData[key] || 0;
                    const angle = angleScale(dim);
                    const r = rScale(value);
                    return {
                        angle,
                        r,
                        x: centerX + Math.cos(angle) * r,
                        y: centerY + Math.sin(angle) * r,
                        dimension: dim,
                        value
                    };
                });

                // Draw area
                const line = d3.lineRadial()
                    .angle(d => d.angle)
                    .radius(d => d.r)
                    .curve(d3.curveLinearClosed);

                const area = svg.append('path')
                    .datum(points)
                    .attr('d', line)
                    .attr('fill', colorScale(provider))
                    .attr('fill-opacity', 0.2)
                    .attr('stroke', colorScale(provider))
                    .attr('stroke-width', 2)
                    .attr('cursor', 'pointer')
                    .on('mouseover', function(event) {
                        tooltip.transition().duration(200).style('opacity', 1);
                        const total = points.reduce((sum, p) => sum + p.value, 0);
                        const avg = total / points.length;
                        tooltip.html(`
                            <div class="tooltip-title">${provider} Identity Surface</div>
                            ${points.map(p => `
                                <div class="tooltip-item"><strong>${p.dimension}:</strong> ${p.value} capabilities</div>
                            `).join('')}
                            <div class="tooltip-item" style="margin-top: 8px; border-top: 1px solid #4a5568; padding-top: 8px;">
                                <strong>Total:</strong> ${total} capabilities | <strong>Average:</strong> ${avg.toFixed(1)} per dimension
                            </div>
                            <div class="tooltip-item" style="margin-top: 8px; font-size: 0.8rem; color: #e53e3e;">
                                ⚠ Higher values indicate greater lock-in risk
                            </div>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                        area.attr('fill-opacity', 0.4);
                    })
                    .on('mouseout', function() {
                        tooltip.transition().duration(200).style('opacity', 0);
                        area.attr('fill-opacity', 0.2);
                    });

                // Draw points
                points.forEach(point => {
                    svg.append('circle')
                        .attr('cx', point.x)
                        .attr('cy', point.y)
                        .attr('r', 4)
                        .attr('fill', colorScale(provider))
                        .attr('stroke', '#e2e8f0')
                        .attr('stroke-width', 2);
                });
            });

            // Legend
            const legend = container.appendChild(document.createElement('div'));
            legend.className = 'chart-legend';
            providers.forEach(provider => {
                const providerData = data[provider];
                const total = Object.values(providerData).reduce((a, b) => a + b, 0);
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${colorScale(provider)}"></div>
                    <div class="legend-text">${provider} (${total} total)</div>
                `;
                legend.appendChild(item);
            });

            // Info panel
            const infoPanel = container.appendChild(document.createElement('div'));
            infoPanel.className = 'chart-info';
            const maxProvider = providers.reduce((a, b) => {
                const totalA = Object.values(data[a]).reduce((s, v) => s + v, 0);
                const totalB = Object.values(data[b]).reduce((s, v) => s + v, 0);
                return totalB > totalA ? b : a;
            });
            infoPanel.innerHTML = `
                <strong>Chart Details:</strong> Radar chart showing identity-linked capability expansion across five dimensions. 
                Larger surfaces indicate more identity binding, which signals higher lock-in risk. 
                <strong>${maxProvider}</strong> shows the largest identity surface expansion. Hover over areas for detailed breakdowns.
            `;

            // Rationale section
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p>The Identity Surface Expansion radar chart is the primary lock-in risk indicator. Identity systems (Workspace, Graph, Account) are the most powerful lock-in mechanisms because they create switching costs that grow with usage. This chart reveals:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Lock-in trajectory:</strong> Larger surfaces indicate providers are binding more capabilities to identity, making switching progressively harder</li>
                        <li><strong>Platform dependencies:</strong> Identity expansion correlates with deeper platform dependencies and reduced user autonomy</li>
                        <li><strong>Market concentration risk:</strong> As identity surfaces expand, markets consolidate around fewer dominant platforms</li>
                        <li><strong>Intervention urgency:</strong> Providers with rapidly expanding surfaces require immediate attention for PLP positioning</li>
                    </ul>
                </div>
                <div class="chart-rationale-section">
                    <strong>How to Interpret:</strong>
                    <p>Each dimension represents a different type of identity binding: Workspace (productivity tools), Graph (data connections), Account (authentication), Cross-App (integration), and Privacy Controls (data governance). Providers with large, balanced surfaces across all dimensions have the highest lock-in risk. Asymmetric expansion (e.g., strong in Graph but weak in Privacy) may indicate strategic priorities or compliance gaps.</p>
                </div>
                <div class="chart-rationale-section">
                    <strong>Strategic Actions:</strong>
                    <ul class="chart-rationale-list">
                        <li>Prioritize competitive responses to providers with rapidly expanding identity surfaces</li>
                        <li>Use asymmetry patterns to identify PLP differentiation opportunities (e.g., stronger privacy controls)</li>
                        <li>Track identity expansion velocity — acceleration indicates urgent market intervention needed</li>
                    </ul>
                </div>
            `);
        }

        // Module 2: Memory Architecture
        function renderMemoryModule() {
            updateMemoryStats();
            renderMemoryAlerts();
            renderOpennessMatrix();
            renderCrossAppGraph();
            renderRecallDepthChart();
        }

        function updateMemoryStats() {
            const providers = dashboardData.memory.providers;
            const avgLockIn = providers.reduce((sum, p) => sum + p.lockInIndex, 0) / providers.length;
            const avgOpenness = providers.reduce((sum, p) => sum + p.opennessScore, 0) / providers.length;
            const avgRecall = providers.reduce((sum, p) => sum + p.recallDepth, 0) / providers.length;
            const avgBoundaries = providers.reduce((sum, p) => sum + p.boundariesScore, 0) / providers.length;
            const avgReach = providers.reduce((sum, p) => sum + p.crossAppReach, 0) / providers.length;
            const avgDefaultOn = providers.reduce((sum, p) => sum + p.defaultOnRate, 0) / providers.length;
            const avgVisibility = providers.reduce((sum, p) => sum + p.visibilityIndex, 0) / providers.length;

            document.getElementById('memoryLockInIndex').textContent = Math.round(avgLockIn);
            document.getElementById('memoryOpennessScore').textContent = Math.round(avgOpenness);
            document.getElementById('memoryRecallDepth').textContent = Math.round(avgRecall / 1000) + 'K';
            document.getElementById('memoryBoundariesScore').textContent = Math.round(avgBoundaries);
            document.getElementById('memoryCrossAppReach').textContent = Math.round(avgReach);
            document.getElementById('memoryDefaultOnRate').textContent = Math.round(avgDefaultOn) + '%';
            document.getElementById('memoryVisibilityIndex').textContent = Math.round(avgVisibility);
        }

        function renderMemoryAlerts() {
            const container = document.getElementById('memoryAlerts');
            const alerts = dashboardData.memory.alerts;
            
            container.innerHTML = '<div style="font-weight: 700; color: #e2e8f0; margin-bottom: 15px;">Smart Alerts</div>';
            
            alerts.forEach(alert => {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert-item ${alert.severity === 'high' ? '' : 'warning'}`;
                alertDiv.innerHTML = `
                    <div class="alert-title">${alert.title}</div>
                    <div class="alert-message">${alert.message} - ${alert.date}</div>
                `;
                container.appendChild(alertDiv);
            });
        }

        function renderOpennessMatrix() {
            const container = document.getElementById('memoryOpennessMatrix');
            const width = container.parentElement.clientWidth - 50;
            const height = 450;
            const margin = { top: 20, right: 30, bottom: 60, left: 60 };

            container.innerHTML = '';

            // Tooltip for combined openness + identity lock-in insight
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const providers = dashboardData.memory.providers;
            const identityLockInData = dashboardData.memory.identityLockIn;
            const identityLockInMap = identityLockInData.reduce((acc, item) => {
                acc[item.provider] = item;
                return acc;
            }, {});

            const xScale = d3.scaleLinear()
                .domain([0, 100])
                .range([0, chartWidth]);

            const yScale = d3.scaleLinear()
                .domain([0, 100])
                .range([chartHeight, 0]);

            // Color scale for identity lock-in percentage
            const colorScale = d3.scaleSequential(d3.interpolateRdYlGn)
                .domain([100, 0]);

            // Size scale for cross-app reach (bubble size)
            const maxReach = d3.max(providers, p => p.crossAppReach || 0) || 1;
            const sizeScale = d3.scaleSqrt()
                .domain([0, maxReach])
                .range([8, 20]);

            // Draw quadrant lines
            g.append('line')
                .attr('x1', xScale(50))
                .attr('y1', 0)
                .attr('x2', xScale(50))
                .attr('y2', chartHeight)
                .attr('stroke', '#4a5568')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            g.append('line')
                .attr('x1', 0)
                .attr('y1', yScale(50))
                .attr('x2', chartWidth)
                .attr('y2', yScale(50))
                .attr('stroke', '#4a5568')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            // Subtle quadrant background shading with labels
            const quadrantConfigs = [
                {
                    label: 'Opportunity Zone',
                    description: 'High Openness • Low Lock-In',
                    xRange: [50, 100],
                    yRange: [0, 50],
                    fill: 'rgba(56, 161, 105, 0.10)'
                },
                {
                    label: 'Strategic Risk',
                    description: 'High Openness • High Lock-In',
                    xRange: [50, 100],
                    yRange: [50, 100],
                    fill: 'rgba(237, 137, 54, 0.10)'
                },
                {
                    label: 'Limited but Manageable',
                    description: 'Low Openness • Low Lock-In',
                    xRange: [0, 50],
                    yRange: [0, 50],
                    fill: 'rgba(99, 179, 237, 0.08)'
                },
                {
                    label: 'Maximum Risk',
                    description: 'Low Openness • High Lock-In',
                    xRange: [0, 50],
                    yRange: [50, 100],
                    fill: 'rgba(229, 62, 62, 0.08)'
                }
            ];

            quadrantConfigs.forEach(q => {
                const x1 = xScale(q.xRange[0]);
                const x2 = xScale(q.xRange[1]);
                const y1 = yScale(q.yRange[1]);
                const y2 = yScale(q.yRange[0]);

                g.append('rect')
                    .attr('x', x1)
                    .attr('y', y1)
                    .attr('width', x2 - x1)
                    .attr('height', y2 - y1)
                    .attr('fill', q.fill)
                    .attr('stroke', 'none');

                g.append('text')
                    .attr('x', x1 + (x2 - x1) / 2)
                    .attr('y', y1 + 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#cbd5e0')
                    .attr('font-size', '11px')
                    .attr('font-weight', '700')
                    .text(q.label);

                g.append('text')
                    .attr('x', x1 + (x2 - x1) / 2)
                    .attr('y', y1 + 36)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#a0aec0')
                    .attr('font-size', '10px')
                    .text(q.description);
            });

            // Plot providers (merged with Identity Lock-In Index)
            providers.forEach(provider => {
                const x = xScale(provider.opennessScore);
                const identityEntry = identityLockInMap[provider.name] || { percentage: provider.lockInIndex, description: '', details: '' };
                const lockInPercent = identityEntry.percentage;
                const y = yScale(lockInPercent);
                const reach = provider.crossAppReach || 0;
                const r = sizeScale(reach);
                
                const circle = g.append('circle')
                    .attr('cx', x)
                    .attr('cy', y)
                    .attr('r', r)
                    .attr('fill', colorScale(lockInPercent))
                    .attr('stroke', '#e2e8f0')
                    .attr('stroke-width', 2)
                    .attr('cursor', 'pointer')
                    .on('click', () => showProviderDetails(provider))
                    .on('mouseover', function(event) {
                        const quadrant =
                            provider.opennessScore >= 50 && lockInPercent < 50 ? 'High Openness + Low Lock-In (Opportunity Zone)' :
                            provider.opennessScore >= 50 && lockInPercent >= 50 ? 'High Openness + High Lock-In (Strategic Risk)' :
                            provider.opennessScore < 50 && lockInPercent < 50 ? 'Low Openness + Low Lock-In (Limited but Manageable)' :
                            'Low Openness + High Lock-In (Maximum Risk)';

                        tooltip.transition().duration(200).style('opacity', 1);
                        tooltip.html(`
                            <div class="tooltip-title">${provider.name} — Openness vs Identity Lock-In</div>
                            <div class="tooltip-item"><strong>Memory Openness Score:</strong> ${provider.opennessScore}</div>
                            <div class="tooltip-item"><strong>Identity Lock-In Index:</strong> ${lockInPercent}%</div>
                            <div class="tooltip-item"><strong>Quadrant:</strong> ${quadrant}</div>
                            <div class="tooltip-item"><strong>Recall Depth:</strong> ${provider.recallDepth.toLocaleString()} tokens</div>
                            <div class="tooltip-item"><strong>Cross-App Reach:</strong> ${provider.crossAppReach} apps</div>
                            <div class="tooltip-item"><strong>Default-On Rate:</strong> ${provider.defaultOnRate}%</div>
                            ${identityEntry.description ? `<div class="tooltip-item" style="margin-top: 8px;"><strong>Identity Binding:</strong> ${identityEntry.description}</div>` : ''}
                            ${identityEntry.details ? `<div class="tooltip-item" style="font-size: 0.8rem; color: #cbd5e0; margin-top: 4px;">${identityEntry.details}</div>` : ''}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');

                        d3.select(this).attr('stroke-width', 3);
                    })
                    .on('mouseout', function() {
                        tooltip.transition().duration(200).style('opacity', 0);
                        d3.select(this).attr('stroke-width', 2);
                    });

                // Label with provider name and lock-in percent
                g.append('text')
                    .attr('x', x)
                    .attr('y', y - 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#e2e8f0')
                    .attr('font-size', '12px')
                    .attr('font-weight', '600')
                    .text(`${provider.name} (${lockInPercent}%)`);
            });

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px');

            g.append('g')
                .call(d3.axisLeft(yScale))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px');

            // Labels
            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + 40)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Memory Openness Score');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -45)
                .attr('x', -chartHeight / 2)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Identity Lock-In Index');

            // Legend explaining color and size encoding
            const legendContainer = container.appendChild(document.createElement('div'));
            legendContainer.className = 'chart-legend';
            legendContainer.style.marginTop = '10px';

            const colorLegend = document.createElement('div');
            colorLegend.className = 'legend-item';
            colorLegend.innerHTML = `
                <div class="legend-color" style="background: linear-gradient(90deg, #48bb78, #f6e05e, #e53e3e); width: 40px;"></div>
                <div class="legend-text">Color = Identity Lock-In (Green = low, Red = high)</div>
            `;
            legendContainer.appendChild(colorLegend);

            const sizeLegend = document.createElement('div');
            sizeLegend.className = 'legend-item';
            sizeLegend.innerHTML = `
                <div class="legend-color" style="background: #4a5568; border-radius: 999px; width: 16px; height: 16px;"></div>
                <div class="legend-text">Bubble Size = Cross-App Memory Reach (# of apps)</div>
            `;
            legendContainer.appendChild(sizeLegend);

            // Prepare computation logic content for rationale
            const sortedLockIn = identityLockInData
                .slice()
                .sort((a, b) => b.percentage - a.percentage);

            const summaryRows = sortedLockIn.map(entry => {
                const band = entry.percentage >= 70 ? 'High' : entry.percentage >= 40 ? 'Medium' : 'Low';
                const providerMeta = providers.find(p => p.name === entry.provider);
                const openness = providerMeta ? providerMeta.opennessScore : '–';
                return `<tr>
                    <td>${entry.provider}</td>
                    <td>${entry.percentage}%</td>
                    <td>${openness}</td>
                    <td>${band}</td>
                </tr>`;
            }).join('');

            const computationLogicHTML = `
                <div class="chart-rationale-section" style="margin-top: 15px;">
                    <strong>Computation Logic (Identity Lock-In Index):</strong>
                    <p style="margin-top: 8px;">
                        Identity Lock-In Index is computed as the share of memory capabilities that <em>require</em> platform identity
                        (Workspace, Graph, account/workspace) out of all weighted memory capabilities:
                    </p>
                    <p style="font-family: monospace; font-size: 0.85rem; margin-top: 6px;">
                        Lock-In % = (Weighted Identity-Dependent Capabilities ÷ Total Weighted Capabilities) × 100
                    </p>
                    <p style="margin-top: 6px; font-size: 0.85rem;">
                        Capabilities are weighted by strategic importance (persistent context, cross-session memory, EDU workflows, governance).
                        The table below summarizes the current scores and bands:
                    </p>
                    <div style="margin-top: 8px; overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
                            <thead>
                                <tr>
                                    <th style="text-align: left; padding: 4px 6px; border-bottom: 1px solid #4a5568;">Provider</th>
                                    <th style="text-align: right; padding: 4px 6px; border-bottom: 1px solid #4a5568;">Lock-In %</th>
                                    <th style="text-align: right; padding: 4px 6px; border-bottom: 1px solid #4a5568;">Openness</th>
                                    <th style="text-align: left; padding: 4px 6px; border-bottom: 1px solid #4a5568;">Band</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${summaryRows}
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top: 8px; font-size: 0.8rem;">
                        The high-openness, low-lock-in quadrant (top-right) represents the most promising opportunity zone for PLP-aligned,
                        student- and institution-controlled memory infrastructure. Providers that move into or remain in this zone
                        should be prioritized for partnership and ecosystem development.
                    </p>
                </div>
            `;

            // Rationale section
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p>The Memory Openness vs Lock-In Matrix is the core strategic visualization for PLP positioning. It maps where each hyperscaler sits on two critical dimensions:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Memory Openness Score:</strong> Measures how open, portable, and user-controllable the memory layer is. Higher scores indicate better data portability, user visibility, and export capabilities</li>
                        <li><strong>Identity Lock-In Index:</strong> Measures how tightly memory is bound to platform identity systems. Higher scores indicate stronger lock-in via Workspace, Graph, or Account dependencies</li>
                        <li><strong>Strategic positioning:</strong> Providers in the high-lock-in, low-openness quadrant (bottom-left) pose the greatest risk. PLP's opportunity is the high-openness, low-lock-in quadrant (top-left, currently empty)</li>
                    </ul>
                    ${computationLogicHTML}
                </div>
                <div class="chart-rationale-section">
                    <strong>How to Interpret:</strong>
                    <p>Click on any provider point to see detailed metrics. The quadrant lines divide providers into four strategic zones: High Openness + Low Lock-In (ideal, PLP opportunity), High Openness + High Lock-In (moderate risk), Low Openness + Low Lock-In (limited but manageable), and Low Openness + High Lock-In (maximum risk). Color intensity indicates lock-in risk level.</p>
                </div>
                <div class="chart-rationale-section">
                    <strong>Strategic Actions:</strong>
                    <ul class="chart-rationale-list">
                        <li>Focus PLP positioning in the high-openness, low-lock-in quadrant — this is the strategic white space</li>
                        <li>Use this matrix to prioritize competitive responses — providers moving toward bottom-left require urgent attention</li>
                        <li>Track provider movement over time — shifts toward higher lock-in or lower openness signal increasing risk</li>
                    </ul>
                </div>
            `);
        }

        function showProviderDetails(provider) {
            alert(`${provider.name} Details:\n\n` +
                  `Lock-In Index: ${provider.lockInIndex}\n` +
                  `Openness Score: ${provider.opennessScore}\n` +
                  `Recall Depth: ${provider.recallDepth.toLocaleString()} tokens\n` +
                  `Cross-App Reach: ${provider.crossAppReach} apps\n` +
                  `Default-On Rate: ${provider.defaultOnRate}%\n` +
                  `Visibility Index: ${provider.visibilityIndex}\n\n` +
                  `Apps: ${provider.apps.join(', ')}`);
        }

        function renderCrossAppGraph() {
            const container = document.getElementById('memoryCrossAppGraph');
            const width = container.parentElement.clientWidth - 50;
            const height = 600;

            container.innerHTML = '';

            // Tooltip
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const providers = dashboardData.memory.providers;
            const providerColors = {
                'Google': '#4285f4',
                'Microsoft': '#00a4ef',
                'OpenAI': '#ff6b35',
                'Anthropic': '#d4a574'
            };

            // Create 2x2 grid layout
            const cols = 2;
            const rows = 2;
            const graphWidth = (width - 60) / cols;
            const graphHeight = (height - 100) / rows;
            const padding = 20;

            providers.forEach((provider, idx) => {
                const col = idx % cols;
                const row = Math.floor(idx / cols);
                const offsetX = col * graphWidth + padding;
                const offsetY = row * graphHeight + 40;
                const g = svg.append('g')
                    .attr('transform', `translate(${offsetX}, ${offsetY})`);

                const centerX = graphWidth / 2;
                const centerY = graphHeight / 2;
                const radius = Math.min(graphWidth, graphHeight) / 3.5;

                // Provider label
                g.append('text')
                    .attr('x', centerX)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('fill', providerColors[provider.name])
                    .attr('font-size', '14px')
                    .attr('font-weight', '700')
                    .text(provider.name);

                // App count label
                g.append('text')
                    .attr('x', centerX)
                    .attr('y', 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#a0aec0')
                    .attr('font-size', '11px')
                    .text(`${provider.apps.length} apps • ${provider.crossAppReach} reach`);

                // Draw center node (Provider)
                const centerNode = g.append('circle')
                    .attr('cx', centerX)
                    .attr('cy', centerY)
                    .attr('r', 25)
                    .attr('fill', providerColors[provider.name])
                    .attr('stroke', '#e2e8f0')
                    .attr('stroke-width', 2)
                    .attr('cursor', 'pointer')
                    .on('mouseover', function(event) {
                        tooltip.transition().duration(200).style('opacity', 1);
                        tooltip.html(`
                            <div class="tooltip-title">${provider.name} Memory Network</div>
                            <div class="tooltip-item"><strong>Cross-App Reach:</strong> ${provider.crossAppReach} apps</div>
                            <div class="tooltip-item"><strong>Total Apps:</strong> ${provider.apps.length}</div>
                            <div class="tooltip-item"><strong>Identity Lock-In:</strong> ${provider.lockInIndex}%</div>
                            <div class="tooltip-item"><strong>Default-On Rate:</strong> ${provider.defaultOnRate}%</div>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                        centerNode.attr('r', 28).attr('stroke-width', 3);
                    })
                    .on('mouseout', function() {
                        tooltip.transition().duration(200).style('opacity', 0);
                        centerNode.attr('r', 25).attr('stroke-width', 2);
                    });

                g.append('text')
                    .attr('x', centerX)
                    .attr('y', centerY + 4)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#ffffff')
                    .attr('font-size', '11px')
                    .attr('font-weight', '600')
                    .text(provider.name.substring(0, 4));

                // Draw app nodes in circle
                const angleStep = (2 * Math.PI) / provider.apps.length;
                provider.apps.forEach((app, i) => {
                    const angle = i * angleStep - Math.PI / 2; // Start at top
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);

                    // Draw line
                    const line = g.append('line')
                        .attr('x1', centerX)
                        .attr('y1', centerY)
                        .attr('x2', x)
                        .attr('y2', y)
                        .attr('stroke', providerColors[provider.name])
                        .attr('stroke-width', 1.5)
                        .attr('opacity', 0.4);

                    // Draw node
                    const appNode = g.append('circle')
                        .attr('cx', x)
                        .attr('cy', y)
                        .attr('r', 12)
                        .attr('fill', '#2d3748')
                        .attr('stroke', providerColors[provider.name])
                        .attr('stroke-width', 2)
                        .attr('cursor', 'pointer')
                        .on('mouseover', function(event) {
                            tooltip.transition().duration(200).style('opacity', 1);
                            tooltip.html(`
                                <div class="tooltip-title">${app}</div>
                                <div class="tooltip-item"><strong>Provider:</strong> ${provider.name}</div>
                                <div class="tooltip-item"><strong>Memory Integration:</strong> Active</div>
                                <div class="tooltip-item" style="font-size: 0.85rem; color: #a0aec0; margin-top: 6px;">
                                    This app contributes signals to ${provider.name}'s unified memory layer
                                </div>
                            `)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                            appNode.attr('r', 15).attr('stroke-width', 3);
                            line.attr('stroke-width', 2.5).attr('opacity', 0.7);
                        })
                        .on('mouseout', function() {
                            tooltip.transition().duration(200).style('opacity', 0);
                            appNode.attr('r', 12).attr('stroke-width', 2);
                            line.attr('stroke-width', 1.5).attr('opacity', 0.4);
                        });

                    // App label - position outside the circle
                    const labelRadius = radius + 30;
                    const labelX = centerX + labelRadius * Math.cos(angle);
                    const labelY = centerY + labelRadius * Math.sin(angle);
                    
                    g.append('text')
                        .attr('x', labelX)
                        .attr('y', labelY + 4)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#a0aec0')
                        .attr('font-size', '9px')
                        .text(app.length > 10 ? app.substring(0, 9) + '...' : app)
                        .style('pointer-events', 'none');
                });
            });

            // Legend
            const legend = container.appendChild(document.createElement('div'));
            legend.className = 'chart-legend';
            legend.style.marginTop = '15px';
            legend.style.textAlign = 'center';

            const legendText = document.createElement('div');
            legendText.style.color = '#a0aec0';
            legendText.style.fontSize = '0.9rem';
            legendText.innerHTML = `
                Each graph shows a provider's memory network with all products/apps connected to the central memory layer.
                <strong style="color: #667eea;">Hover over nodes for details.</strong>
            `;
            legend.appendChild(legendText);

            // Rationale section
            const allProviders = dashboardData.memory.providers;
            const maxReach = Math.max(...allProviders.map(p => p.crossAppReach));
            const totalApps = allProviders.reduce((sum, p) => sum + p.apps.length, 0);
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p>The Cross-App Memory Reach graph visualizes how many internal apps contribute signals to each platform's memory layer. This is critical because:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Lock-in multiplier:</strong> Each app that feeds memory increases switching costs exponentially — users must replace the entire ecosystem, not just one tool</li>
                        <li><strong>Network effects:</strong> More apps contributing to memory creates stronger network effects and deeper platform dependencies</li>
                        <li><strong>Data accumulation:</strong> Cross-app memory reach indicates how much user data accumulates in a platform's memory layer over time</li>
                        <li><strong>Competitive moat:</strong> Providers with high cross-app reach (${maxReach}+ apps) have built formidable competitive moats</li>
                    </ul>
                    <div style="margin-top: 15px; padding: 12px; background: rgba(45, 55, 72, 0.5); border-radius: 6px;">
                        <strong style="color: #667eea; display: block; margin-bottom: 8px;">Cross-App Reach Comparison:</strong>
                        ${allProviders.map(p => `
                            <div style="margin: 6px 0; font-size: 0.9rem;">
                                <strong style="color: ${providerColors[p.name]};">${p.name}:</strong> ${p.apps.length} apps connected (${p.crossAppReach} reach) — 
                                ${p.apps.slice(0, 5).join(', ')}${p.apps.length > 5 ? ', ...' : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="chart-rationale-section">
                    <strong>How to Interpret:</strong>
                    <p>Each provider's graph shows a hub-and-spoke architecture where the central node represents the unified memory layer, and surrounding nodes represent individual apps/products that contribute signals. Microsoft has the highest reach (${allProviders.find(p => p.crossAppReach === maxReach)?.crossAppReach} apps), followed by Google (${allProviders.find(p => p.name === 'Google')?.crossAppReach} apps). Each connection represents a data flow that increases lock-in. The number of apps connected directly correlates with switching costs — providers with 10+ app connections have the highest lock-in risk.</p>
                </div>
                <div class="chart-rationale-section">
                    <strong>Strategic Actions:</strong>
                    <ul class="chart-rationale-list">
                        <li>Monitor cross-app reach increases — each new app connection multiplies lock-in risk</li>
                        <li>Prioritize competitive responses to providers with >10 app connections — these have built strong moats</li>
                        <li>Focus PLP positioning on inter-operability — enabling memory across different apps reduces lock-in</li>
                        <li>Track which apps contribute most to memory — these are the highest-value targets for open alternatives</li>
                    </ul>
                </div>
            `);
        }

        function renderRecallDepthChart() {
            const container = document.getElementById('memoryRecallDepthChart');
            const width = container.parentElement.clientWidth - 50;
            const height = 450;
            const margin = { top: 40, right: 100, bottom: 80, left: 80 };

            container.innerHTML = '';

            // Create tooltip
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const data = dashboardData.memory.recallDepthHistory.sort((a, b) => new Date(a.date + '-01') - new Date(b.date + '-01'));

            // Group by provider
            const providers = ['GPT', 'Claude', 'Gemini'];
            const providerColors = { 'GPT': '#ff6b35', 'Claude': '#e67e22', 'Gemini': '#4285f4' };
            
            const dataByProvider = {};
            data.forEach(d => {
                const provider = d.model.split('-')[0].split('_')[0];
                if (!dataByProvider[provider]) dataByProvider[provider] = [];
                dataByProvider[provider].push({ ...d, provider });
            });

            const xScale = d3.scaleTime()
                .domain(d3.extent(data, d => new Date(d.date + '-01')))
                .range([0, chartWidth]);

            const yScale = d3.scaleLog()
                .domain([1000, 300000])
                .range([chartHeight, 0]);

            // Draw lines for each provider
            Object.keys(dataByProvider).forEach(provider => {
                const providerData = dataByProvider[provider];
                const line = d3.line()
                    .x(d => xScale(new Date(d.date + '-01')))
                    .y(d => yScale(d.depth))
                    .curve(d3.curveMonotoneX);

                g.append('path')
                    .datum(providerData)
                    .attr('fill', 'none')
                    .attr('stroke', providerColors[provider] || '#667eea')
                    .attr('stroke-width', 3)
                    .attr('opacity', 0.8)
                    .attr('d', line);
            });

            // Points with tooltips and annotations
            data.forEach((d, i) => {
                const date = new Date(d.date + '-01');
                const x = xScale(date);
                const y = yScale(d.depth);
                const provider = d.model.split('-')[0].split('_')[0];

                // Calculate growth
                const prev = i > 0 ? data[i - 1] : null;
                const growth = prev ? ((d.depth - prev.depth) / prev.depth * 100) : 0;
                const isMajorJump = growth > 100;

                // Point
                const circle = g.append('circle')
                    .attr('cx', x)
                    .attr('cy', y)
                    .attr('r', isMajorJump ? 8 : 6)
                    .attr('fill', providerColors[provider] || '#667eea')
                    .attr('stroke', '#e2e8f0')
                    .attr('stroke-width', isMajorJump ? 3 : 2)
                    .attr('cursor', 'pointer')
                    .style('opacity', 0.9);

                // Model label
                const labelOffset = y < chartHeight / 2 ? -20 : 20;
                g.append('text')
                    .attr('x', x)
                    .attr('y', y + labelOffset)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#e2e8f0')
                    .attr('font-size', '10px')
                    .attr('font-weight', '600')
                    .text(d.model);

                // Annotation for major jumps
                if (isMajorJump) {
                    g.append('line')
                        .attr('x1', x)
                        .attr('y1', y - 15)
                        .attr('x2', x)
                        .attr('y2', y - 30)
                        .attr('stroke', '#e53e3e')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '3,3');

                    g.append('text')
                        .attr('x', x)
                        .attr('y', y - 35)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#e53e3e')
                        .attr('font-size', '11px')
                        .attr('font-weight', '700')
                        .text(`+${growth.toFixed(0)}%`);
                }

                // Tooltip
                circle.on('mouseover', function(event) {
                    tooltip.transition().duration(200).style('opacity', 1);
                    tooltip.html(`
                        <div class="tooltip-title">${d.model}</div>
                        <div class="tooltip-item"><strong>Provider:</strong> ${provider}</div>
                        <div class="tooltip-item"><strong>Release Date:</strong> ${d3.timeFormat('%B %Y')(date)}</div>
                        <div class="tooltip-item"><strong>Recall Depth:</strong> ${d.depth.toLocaleString()} tokens</div>
                        <div class="tooltip-item"><strong>Human Equivalent:</strong> ~${Math.round(d.depth / 750)} pages</div>
                        ${prev ? `
                            <div class="tooltip-item" style="margin-top: 8px; border-top: 1px solid #4a5568; padding-top: 8px;">
                                <strong>Previous:</strong> ${prev.model} (${prev.depth.toLocaleString()} tokens)
                            </div>
                            <div class="tooltip-item"><strong>Growth:</strong> ${growth > 0 ? '+' : ''}${growth.toFixed(1)}%</div>
                            <div class="tooltip-item"><strong>Absolute Increase:</strong> +${(d.depth - prev.depth).toLocaleString()} tokens</div>
                            ${isMajorJump ? '<div class="tooltip-item" style="color: #e53e3e; font-weight: 600;">⚠ Major recall depth increase - high personalization risk</div>' : ''}
                        ` : '<div class="tooltip-item">First tracked release</div>'}
                        <div class="tooltip-item" style="margin-top: 8px; font-size: 0.8rem; color: #667eea;">
                            Deeper recall → Better context → Higher lock-in risk
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                    
                    circle.attr('r', isMajorJump ? 10 : 8).style('opacity', 1);
                })
                .on('mouseout', function() {
                    tooltip.transition().duration(200).style('opacity', 0);
                    circle.attr('r', isMajorJump ? 8 : 6).style('opacity', 0.9);
                });
            });

            // Highlight high-risk zone (above 100K tokens)
            const riskThreshold = 100000;
            g.append('rect')
                .attr('x', 0)
                .attr('y', yScale(riskThreshold))
                .attr('width', chartWidth)
                .attr('height', yScale(1000) - yScale(riskThreshold))
                .attr('fill', 'rgba(229, 62, 62, 0.1)')
                .attr('stroke', '#e53e3e')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '5,5');

            g.append('text')
                .attr('x', chartWidth - 10)
                .attr('y', yScale(riskThreshold) + 15)
                .attr('text-anchor', 'end')
                .attr('fill', '#e53e3e')
                .attr('font-size', '11px')
                .attr('font-weight', '600')
                .text('High Risk Zone (>100K tokens)');

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale).ticks(8).tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end');

            g.append('g')
                .call(d3.axisLeft(yScale).tickFormat(d => d / 1000 + 'K'))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px');

            // Axis labels
            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + 60)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Model Release Date');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -60)
                .attr('x', -chartHeight / 2)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Effective Recall Depth (tokens, log scale)');

            // Legend
            const legend = container.appendChild(document.createElement('div'));
            legend.className = 'chart-legend';
            Object.keys(dataByProvider).forEach(provider => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                const maxDepth = Math.max(...dataByProvider[provider].map(d => d.depth));
                item.innerHTML = `
                    <div class="legend-color" style="background: ${providerColors[provider] || '#667eea'}"></div>
                    <div class="legend-text">${provider} (max: ${(maxDepth / 1000).toFixed(0)}K tokens)</div>
                `;
                legend.appendChild(item);
            });

            // Info panel
            const infoPanel = container.appendChild(document.createElement('div'));
            infoPanel.className = 'chart-info';
            const maxModel = data.reduce((a, b) => b.depth > a.depth ? b : a);
            const avgDepth = data.reduce((sum, d) => sum + d.depth, 0) / data.length;
            infoPanel.innerHTML = `
                <strong>Chart Details:</strong> Long-term trend of effective recall depth by model version. Logarithmic scale shows exponential growth in memory capacity.
                The shaded red zone indicates high-risk territory (>100K tokens) where lock-in risk increases significantly. 
                <strong>${maxModel.model}</strong> has the highest recall depth at ${maxModel.depth.toLocaleString()} tokens. 
                Average across all models: ${(avgDepth / 1000).toFixed(0)}K tokens. Major jumps (marked with red annotations) signal critical moments where personalization capabilities dramatically increase.
            `;

            // Rationale section
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p>Effective Recall Depth is the key predictor of personalization capability and lock-in risk. This metric measures how much context a model can maintain across conversations, directly correlating with:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Personalization quality:</strong> Deeper recall enables more sophisticated, context-aware personalization that users value highly</li>
                        <li><strong>Switching costs:</strong> As recall depth increases, users accumulate more contextual memory, making switching platforms progressively harder</li>
                        <li><strong>Lock-in acceleration:</strong> Models with >100K token recall create exponential lock-in — the more users engage, the more valuable the memory becomes</li>
                        <li><strong>Competitive dynamics:</strong> Rapid increases in recall depth (marked by red annotations) signal strategic investments in lock-in infrastructure</li>
                    </ul>
                </div>
                <div class="chart-rationale-section">
                    <strong>How to Interpret:</strong>
                    <p>The logarithmic scale reveals exponential growth in memory capacity. Major jumps (>100% growth) indicate breakthrough moments where personalization capabilities leap forward. The red high-risk zone (>100K tokens) represents territory where lock-in becomes nearly irreversible. Provider lines show competitive trajectories — convergence indicates commoditization, divergence signals competitive advantage.</p>
                </div>
                <div class="chart-rationale-section">
                    <strong>Strategic Actions:</strong>
                    <ul class="chart-rationale-list">
                        <li>Monitor recall depth increases — major jumps require immediate competitive response planning</li>
                        <li>Prioritize providers approaching or exceeding 100K tokens as highest lock-in risk</li>
                        <li>Use recall depth trends to time PLP interventions — rapid increases signal closing windows</li>
                        <li>Track which providers maintain deeper recall with more open systems — this is the differentiation opportunity</li>
                    </ul>
                </div>
            `);
        }

        // Module 3: Education Integration
        function renderEducationModule() {
            updateEducationStats();
            renderEducationAlerts();
            renderEducationHeatmap();
            renderEcosystemRisk();
            renderPublicGoodRiskGradient();
        }

        function updateEducationStats() {
            const providers = dashboardData.education.providers;
            const avgIntegration = providers.reduce((sum, p) => sum + p.integrationScore, 0) / providers.length;
            const totalIntegrations = providers.reduce((sum, p) => sum + p.lmsIntegrations.length, 0);
            const avgWorkflow = providers.reduce((sum, p) => sum + p.workflowCoverage, 0) / providers.length;
            const avgPenetration = providers.reduce((sum, p) => sum + p.districtPenetration, 0) / providers.length;
            const totalWorkloads = providers.reduce((sum, p) => sum + p.agentWorkloads.length, 0);

            document.getElementById('educationIntegrationScore').textContent = Math.round(avgIntegration);
            document.getElementById('educationLMSIntegrations').textContent = totalIntegrations;
            document.getElementById('educationWorkflowCoverage').textContent = Math.round(avgWorkflow) + '%';
            document.getElementById('educationDistrictPenetration').textContent = Math.round(avgPenetration) + '%';
            document.getElementById('educationAgentWorkloads').textContent = totalWorkloads;
        }

        function renderEducationAlerts() {
            const container = document.getElementById('educationAlerts');
            const alerts = dashboardData.education.alerts;
            
            container.innerHTML = '<div style="font-weight: 700; color: #e2e8f0; margin-bottom: 15px;">Smart Alerts</div>';
            
            alerts.forEach(alert => {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert-item ${alert.severity === 'high' ? '' : 'warning'}`;
                alertDiv.innerHTML = `
                    <div class="alert-title">${alert.title}</div>
                    <div class="alert-message">${alert.message} - ${alert.date}</div>
                `;
                container.appendChild(alertDiv);
            });
        }

        function renderEducationHeatmap() {
            const container = document.getElementById('educationIntegrationHeatmap');
            const width = container.parentElement.clientWidth - 50;
            const height = 500;
            const margin = { top: 80, right: 100, bottom: 90, left: 140 };

            container.innerHTML = '';

            // Create tooltip
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('overflow', 'visible');

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const providers = dashboardData.education.providers;
            const useCases = ['AI Tutoring', 'Automated Grading', 'Real-time Feedback', 'Instructional Planning', 'Teacher Coaching'];
            
            const providerColors = {
                'Google': '#4285f4',
                'Microsoft': '#00a4ef',
                'OpenAI': '#ff6b35',
                'Anthropic': '#d4a574'
            };

            // Prepare data
            const data = [];
            providers.forEach(provider => {
                useCases.forEach(useCase => {
                    const value = provider.useCases[useCase] || 0;
                    data.push({
                        provider: provider.name,
                        useCase: useCase,
                        value: value
                    });
                });
            });

            // Scales
            const xScale = d3.scaleBand()
                .domain(useCases)
                .range([0, chartWidth])
                .padding(0.05);

            const yScale = d3.scaleBand()
                .domain(providers.map(p => p.name))
                .range([0, chartHeight])
                .padding(0.05);

            // Color scale (green = low, yellow = medium, red = high)
            const colorScale = d3.scaleSequential(d3.interpolateRdYlGn)
                .domain([100, 0]);

            // Draw cells
            const cells = g.selectAll('.cell')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', 'cell')
                .attr('x', d => xScale(d.useCase))
                .attr('y', d => yScale(d.provider))
                .attr('width', xScale.bandwidth())
                .attr('height', yScale.bandwidth())
                .attr('fill', d => colorScale(d.value))
                .attr('stroke', '#2d3748')
                .attr('stroke-width', 2)
                .attr('rx', 4)
                .attr('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    tooltip.transition().duration(200).style('opacity', 1);
                    const riskLevel = d.value >= 80 ? 'High Lock-In Risk' : d.value >= 40 ? 'Moderate Integration' : 'Opportunity Zone';
                    tooltip.html(`
                        <div class="tooltip-title">${d.provider} × ${d.useCase}</div>
                        <div class="tooltip-item"><strong>Integration Score:</strong> ${d.value}%</div>
                        <div class="tooltip-item"><strong>Risk Level:</strong> ${riskLevel}</div>
                        <div class="tooltip-item" style="margin-top: 8px; font-size: 0.85rem; color: #a0aec0;">
                            ${d.value >= 80 ? 'Deep workflow embedding — high switching costs' : 
                              d.value >= 40 ? 'Moderate integration — room for competition' : 
                              'Low integration — PLP opportunity'}
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                    
                    d3.select(this)
                        .attr('stroke', providerColors[d.provider] || '#667eea')
                        .attr('stroke-width', 3);
                })
                .on('mouseout', function() {
                    tooltip.transition().duration(200).style('opacity', 0);
                    d3.select(this)
                        .attr('stroke', '#2d3748')
                        .attr('stroke-width', 2);
                });

            // Add value labels
            g.selectAll('.value-label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'value-label')
                .attr('x', d => xScale(d.useCase) + xScale.bandwidth() / 2)
                .attr('y', d => yScale(d.provider) + yScale.bandwidth() / 2)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'central')
                .attr('fill', d => d.value > 50 ? '#ffffff' : '#1a202c')
                .attr('font-size', '11px')
                .attr('font-weight', '700')
                .style('overflow', 'visible')
                .text(d => d.value + '%');

            // X-axis (Use Cases)
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end')
                .attr('dx', '-0.5em')
                .attr('dy', '0.5em')
                .style('overflow', 'visible');

            // Y-axis (Providers)
            g.append('g')
                .call(d3.axisLeft(yScale))
                .selectAll('text')
                .attr('fill', d => providerColors[d] || '#e2e8f0')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .attr('dx', '-0.5em')
                .style('overflow', 'visible');

            // Axis labels
            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + 70)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '13px')
                .style('overflow', 'visible')
                .text('EDU Use Cases');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -115)
                .attr('x', -chartHeight / 2)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '13px')
                .style('overflow', 'visible')
                .text('Providers');

            // Legend
            const legendWidth = 300;
            const legendHeight = 20;
            const legendX = chartWidth - legendWidth;
            const legendY = -60;

            const legendScale = d3.scaleLinear()
                .domain([0, 100])
                .range([0, legendWidth]);

            const legendAxis = d3.axisBottom(legendScale)
                .ticks(5)
                .tickFormat(d => d + '%');

            const legendG = g.append('g')
                .attr('transform', `translate(${legendX}, ${legendY})`);

            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'heatmap-gradient')
                .attr('x1', '0%')
                .attr('x2', '100%');

            const colorStops = [0, 25, 50, 75, 100];
            colorStops.forEach(stop => {
                gradient.append('stop')
                    .attr('offset', `${stop}%`)
                    .attr('stop-color', colorScale(100 - stop));
            });

            legendG.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#heatmap-gradient)')
                .attr('stroke', '#4a5568')
                .attr('stroke-width', 1);

            legendG.append('g')
                .attr('transform', `translate(0, ${legendHeight})`)
                .call(legendAxis)
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '10px');

            legendG.append('text')
                .attr('x', legendWidth / 2)
                .attr('y', -5)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px')
                .style('font-weight', '600')
                .text('Integration Score (0% = Green, 100% = Red)');

            // Risk zone annotations
            const riskZones = [
                { y: -45, label: 'High Risk (>80%)', color: '#e53e3e' },
                { y: -30, label: 'Moderate (40-80%)', color: '#ed8936' },
                { y: -15, label: 'Opportunity (<40%)', color: '#48bb78' }
            ];

            riskZones.forEach((zone, i) => {
                legendG.append('rect')
                    .attr('x', legendWidth + 20)
                    .attr('y', zone.y - 8)
                    .attr('width', 12)
                    .attr('height', 12)
                    .attr('fill', zone.color)
                    .attr('rx', 2);

                legendG.append('text')
                    .attr('x', legendWidth + 35)
                    .attr('y', zone.y)
                    .attr('fill', '#a0aec0')
                    .style('font-size', '10px')
                    .text(zone.label);
            });

            // Rationale section
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p><strong>Why This Chart Matters:</strong></p>
                    <p>The Education Integration Heatmap reveals where each hyperscaler has embedded AI into educational workflows. This is critical because:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Workflow lock-in:</strong> Once AI is embedded in instructional workflows (AI Tutoring, Automated Grading, Real-time Feedback, Instructional Planning, Teacher Coaching), switching costs become prohibitive. Teachers become dependent on platform-specific AI tools that learn their teaching style, creating deep structural dependencies.</li>
                        <li><strong>District dependency:</strong> High integration scores indicate districts are becoming dependent on specific platforms for core educational functions. When a platform captures multiple workflow categories (>80% in several areas), districts cannot easily switch without disrupting instruction.</li>
                        <li><strong>Competitive gaps:</strong> White spaces in the heatmap (low percentages, green cells) identify where PLP can differentiate with open alternatives. Categories with <40% integration across providers represent strategic opportunities for open-source or student-controlled alternatives.</li>
                        <li><strong>Memory usage signals:</strong> Integration across multiple use cases often correlates with memory system usage, compounding lock-in risk. When platforms use persistent memory across tutoring, grading, and feedback, student data accumulates in proprietary systems.</li>
                        <li><strong>Category-specific risks:</strong> Each of the five categories represents a different lock-in vector: AI Tutoring creates student-level dependencies, Automated Grading creates institutional dependencies, Real-time Feedback embeds AI in daily instruction, Instructional Planning captures teacher workflows, and Teacher Coaching builds administrative lock-in.</li>
                    </ul>
                    <div class="chart-rationale-section" style="margin-top: 20px;">
                        <strong>How to Interpret:</strong>
                        <p>Color intensity (green → yellow → red) indicates integration depth. Red cells (>80%) signal deep workflow embedding where platforms have become essential. Yellow cells (40-80%) indicate moderate integration with room for competition. Green cells (<40%) are opportunities where PLP can establish presence. Horizontal patterns show provider strengths across categories; vertical patterns show which categories are most contested. Hover over cells to see detailed integration scores and risk levels.</p>
                    </div>
                    <div class="chart-rationale-section" style="margin-top: 15px;">
                        <strong>Strategic Actions:</strong>
                        <ul class="chart-rationale-list">
                            <li>Prioritize red cells (>80%) for competitive monitoring — these represent highest lock-in risk areas where platforms have become essential</li>
                            <li>Target green/yellow cells (<60%) for PLP positioning — these are underserved markets with lower switching costs where open alternatives can gain traction</li>
                            <li>Track changes in categories like AI Tutoring and Teacher Coaching — these are emerging areas with less established lock-in where PLP can establish early presence</li>
                            <li>Monitor which providers expand fastest across categories — this signals aggressive education market strategies and requires competitive responses</li>
                            <li>Focus on categories where multiple providers show high integration (>70%) — these indicate mature markets where differentiation is harder but switching costs create opportunity</li>
                        </ul>
                    </div>
                </div>
            `);
        }

        function renderEcosystemRisk() {
            const container = document.getElementById('educationEcosystemRiskChart');
            const width = container.parentElement.clientWidth - 50;
            const height = 350;
            const margin = { top: 20, right: 30, bottom: 60, left: 60 };

            container.innerHTML = '';

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const data = Object.entries(dashboardData.education.ecosystemRisk);
            const colorScale = d3.scaleOrdinal()
                .domain(data.map(d => d[0]))
                .range(['#4285f4', '#00a4ef', '#ff6b35', '#48bb78']);

            const xScale = d3.scaleBand()
                .domain(data.map(d => d[0]))
                .range([0, chartWidth])
                .padding(0.2);

            const yScale = d3.scaleLinear()
                .domain([0, 100])
                .range([chartHeight, 0]);

            // Bars
            g.selectAll('rect')
                .data(data)
                .enter()
                .append('rect')
                .attr('x', d => xScale(d[0]))
                .attr('y', d => yScale(d[1]))
                .attr('width', xScale.bandwidth())
                .attr('height', d => chartHeight - yScale(d[1]))
                .attr('fill', d => colorScale(d[0]))
                .attr('rx', 4);

            // Labels on bars
            g.selectAll('text')
                .data(data)
                .enter()
                .append('text')
                .attr('x', d => xScale(d[0]) + xScale.bandwidth() / 2)
                .attr('y', d => yScale(d[1]) - 5)
                .attr('text-anchor', 'middle')
                .attr('fill', '#e2e8f0')
                .attr('font-size', '14px')
                .attr('font-weight', '600')
                .text(d => d[1] + '%');

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '12px');

            g.append('g')
                .call(d3.axisLeft(yScale).ticks(5))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '12px');

            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + 40)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Provider');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -45)
                .attr('x', -chartHeight / 2)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '14px')
                .text('Market Share (%)');

            // Rationale section
            const ecosystemRisk = dashboardData.education.ecosystemRisk;
            const topProvider = Object.entries(ecosystemRisk).reduce((a, b) => b[1] > a[1] ? b : a);
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p>The Ecosystem Risk View shows which providers are becoming the default "context layer" in education. Derived from district adoption patterns (58/27/12/<1), this chart reveals:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Market concentration risk:</strong> When one provider controls >50% market share, lock-in becomes systemic and switching becomes nearly impossible at scale</li>
                        <li><strong>Default platform effects:</strong> Providers with high market share become de facto standards, creating network effects that accelerate lock-in</li>
                        <li><strong>Context layer dominance:</strong> The provider controlling the context layer (where memory lives) controls the ecosystem, regardless of other integrations</li>
                        <li><strong>Timing urgency:</strong> As market share concentrates, windows for PLP intervention close rapidly</li>
                    </ul>
                </div>
                <div class="chart-rationale-section">
                    <strong>How to Interpret:</strong>
                    <p>This chart displays the distribution of platform adoption across districts. <strong>${topProvider[0]}</strong> leads with ${topProvider[1]}% market share. Providers with >50% share have achieved critical mass where lock-in becomes systemic. The 58/27/15 distribution (Google/Microsoft/Others) indicates a duopoly emerging in education, with significant risk of further concentration.</p>
                </div>
                <div class="chart-rationale-section">
                    <strong>Strategic Actions:</strong>
                    <ul class="chart-rationale-list">
                        <li>Monitor shifts toward >60% market share — this signals approaching monopoly risk requiring immediate intervention</li>
                        <li>Prioritize PLP positioning in markets with 30-50% concentration — these are windows before lock-in becomes irreversible</li>
                        <li>Track rapid adoption spikes — these indicate closing windows where platforms are accelerating lock-in</li>
                        <li>Focus on districts in the "Others" category — these are early PLP adoption opportunities</li>
                    </ul>
                </div>
            `);
        }

        function renderPublicGoodRiskGradient() {
            const container = document.getElementById('educationPublicGoodRiskGradient');
            const width = container.parentElement.clientWidth - 50;
            const height = 450;
            const margin = { top: 80, right: 100, bottom: 80, left: 140 };

            container.innerHTML = '';

            // Create tooltip
            const tooltip = d3.select(container).append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('overflow', 'visible');

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Risk categories and providers
            const riskCategories = ['Education Dependency', 'Lock-In Risk', 'Openness Risk', 'Memory Integration Risk'];
            const providers = ['Google', 'Microsoft', 'OpenAI', 'Anthropic'];
            
            const providerColors = {
                'Google': '#4285f4',
                'Microsoft': '#00a4ef',
                'OpenAI': '#ff6b35',
                'Anthropic': '#d4a574'
            };

            // Risk data - combining data from different sources
            const riskData = [
                { provider: 'Google', category: 'Education Dependency', value: 92 },
                { provider: 'Google', category: 'Lock-In Risk', value: 85 },
                { provider: 'Google', category: 'Openness Risk', value: 75 },
                { provider: 'Google', category: 'Memory Integration Risk', value: 90 },
                { provider: 'Microsoft', category: 'Education Dependency', value: 87 },
                { provider: 'Microsoft', category: 'Lock-In Risk', value: 82 },
                { provider: 'Microsoft', category: 'Openness Risk', value: 65 },
                { provider: 'Microsoft', category: 'Memory Integration Risk', value: 85 },
                { provider: 'OpenAI', category: 'Education Dependency', value: 65 },
                { provider: 'OpenAI', category: 'Lock-In Risk', value: 85 },
                { provider: 'OpenAI', category: 'Openness Risk', value: 50 },
                { provider: 'OpenAI', category: 'Memory Integration Risk', value: 75 },
                { provider: 'Anthropic', category: 'Education Dependency', value: 45 },
                { provider: 'Anthropic', category: 'Lock-In Risk', value: 70 },
                { provider: 'Anthropic', category: 'Openness Risk', value: 40 },
                { provider: 'Anthropic', category: 'Memory Integration Risk', value: 60 }
            ];

            // Scales
            const xScale = d3.scaleBand()
                .domain(riskCategories)
                .range([0, chartWidth])
                .padding(0.05);

            const yScale = d3.scaleBand()
                .domain(providers)
                .range([0, chartHeight])
                .padding(0.05);

            // Color scale (green = low risk, yellow = medium, red = high risk)
            const colorScale = d3.scaleSequential(d3.interpolateRdYlGn)
                .domain([100, 0]);

            // Draw cells
            const cells = g.selectAll('.cell')
                .data(riskData)
                .enter()
                .append('rect')
                .attr('class', 'cell')
                .attr('x', d => xScale(d.category))
                .attr('y', d => yScale(d.provider))
                .attr('width', xScale.bandwidth())
                .attr('height', yScale.bandwidth())
                .attr('fill', d => colorScale(d.value))
                .attr('stroke', '#2d3748')
                .attr('stroke-width', 2)
                .attr('rx', 4)
                .attr('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    tooltip.transition().duration(200).style('opacity', 1);
                    const riskLevel = d.value >= 80 ? 'High Risk' : d.value >= 50 ? 'Medium Risk' : 'Low Risk';
                    tooltip.html(`
                        <div class="tooltip-title">${d.provider} × ${d.category}</div>
                        <div class="tooltip-item"><strong>Risk Score:</strong> ${d.value}%</div>
                        <div class="tooltip-item"><strong>Risk Level:</strong> ${riskLevel}</div>
                        <div class="tooltip-item" style="margin-top: 8px; font-size: 0.85rem; color: #a0aec0;">
                            ${d.value >= 80 ? 'High risk — education heavily dependent on closed memory systems' : 
                              d.value >= 50 ? 'Medium risk — moderate dependency with room for PLP intervention' : 
                              'Low risk — higher adoption potential for PLP alternatives'}
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                    
                    d3.select(this)
                        .attr('stroke', providerColors[d.provider] || '#667eea')
                        .attr('stroke-width', 3);
                })
                .on('mouseout', function() {
                    tooltip.transition().duration(200).style('opacity', 0);
                    d3.select(this)
                        .attr('stroke', '#2d3748')
                        .attr('stroke-width', 2);
                });

            // Add value labels
            g.selectAll('.value-label')
                .data(riskData)
                .enter()
                .append('text')
                .attr('class', 'value-label')
                .attr('x', d => xScale(d.category) + xScale.bandwidth() / 2)
                .attr('y', d => yScale(d.provider) + yScale.bandwidth() / 2)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'central')
                .attr('fill', d => d.value > 50 ? '#ffffff' : '#1a202c')
                .attr('font-size', '11px')
                .attr('font-weight', '700')
                .style('overflow', 'visible')
                .text(d => d.value + '%');

            // X-axis (Risk Categories)
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end')
                .attr('dx', '-0.5em')
                .attr('dy', '0.5em')
                .style('overflow', 'visible');

            // Y-axis (Providers)
            g.append('g')
                .call(d3.axisLeft(yScale))
                .selectAll('text')
                .attr('fill', d => providerColors[d] || '#e2e8f0')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .attr('dx', '-0.5em')
                .style('overflow', 'visible');

            // Axis labels
            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + 70)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '13px')
                .style('overflow', 'visible')
                .text('Risk Categories');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -115)
                .attr('x', -chartHeight / 2)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '13px')
                .style('overflow', 'visible')
                .text('Providers');

            // Legend
            const legendWidth = 300;
            const legendHeight = 20;
            const legendX = chartWidth - legendWidth;
            const legendY = -60;

            const legendScale = d3.scaleLinear()
                .domain([0, 100])
                .range([0, legendWidth]);

            const legendAxis = d3.axisBottom(legendScale)
                .ticks(5)
                .tickFormat(d => d + '%');

            const legendG = g.append('g')
                .attr('transform', `translate(${legendX}, ${legendY})`);

            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'risk-gradient')
                .attr('x1', '0%')
                .attr('x2', '100%');

            const colorStops = [0, 25, 50, 75, 100];
            colorStops.forEach(stop => {
                gradient.append('stop')
                    .attr('offset', `${stop}%`)
                    .attr('stop-color', colorScale(100 - stop));
            });

            legendG.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#risk-gradient)')
                .attr('stroke', '#4a5568')
                .attr('stroke-width', 1);

            legendG.append('g')
                .attr('transform', `translate(0, ${legendHeight})`)
                .call(legendAxis)
                .selectAll('text')
                .attr('fill', '#a0aec0')
                .style('font-size', '10px');

            legendG.append('text')
                .attr('x', legendWidth / 2)
                .attr('y', -5)
                .style('text-anchor', 'middle')
                .attr('fill', '#a0aec0')
                .style('font-size', '11px')
                .style('font-weight', '600')
                .text('Risk Score (0% = Green/Low Risk, 100% = Red/High Risk)');

            // Risk zone annotations
            const riskZones = [
                { y: -45, label: 'High Risk (80-100%)', color: '#e53e3e' },
                { y: -30, label: 'Medium Risk (50-79%)', color: '#ed8936' },
                { y: -15, label: 'Low Risk (0-49%)', color: '#48bb78' }
            ];

            riskZones.forEach((zone, i) => {
                legendG.append('rect')
                    .attr('x', legendWidth + 20)
                    .attr('y', zone.y - 8)
                    .attr('width', 12)
                    .attr('height', 12)
                    .attr('fill', zone.color)
                    .attr('rx', 2);

                legendG.append('text')
                    .attr('x', legendWidth + 35)
                    .attr('y', zone.y)
                    .attr('fill', '#a0aec0')
                    .style('font-size', '10px')
                    .text(zone.label);
            });

            // Rationale section
            createCollapsibleRationale(container, `
                <div class="chart-rationale-content">
                    <p><strong>Why This Chart Matters:</strong></p>
                    <p>The Public-Good Risk Gradient heatmap visualizes the level of risk across four critical dimensions for each major provider. This is essential for understanding where PLP intervention is most urgent:</p>
                    <ul class="chart-rationale-list">
                        <li><strong>Education Dependency:</strong> Measures how heavily education relies on a provider's platform for core functions. High dependency (>80%) means districts cannot easily switch without major disruption.</li>
                        <li><strong>Lock-In Risk:</strong> Measures how tightly bound educational institutions are to a provider's identity and ecosystem. High lock-in (>80%) creates structural dependencies that prevent portability.</li>
                        <li><strong>Openness Risk:</strong> Measures how closed a provider's memory and data systems are. High risk (>70%) indicates limited data portability and user control, making PLP alternatives essential.</li>
                        <li><strong>Memory Integration Risk:</strong> Measures how deeply memory systems are embedded in educational workflows. High risk (>80%) means student data is accumulating in proprietary systems, creating long-term lock-in.</li>
                    </ul>
                    <div style="margin-top: 15px; padding: 12px; background: rgba(45, 55, 72, 0.5); border-radius: 6px;">
                        <strong style="color: #667eea; display: block; margin-bottom: 8px;">Risk Patterns by Provider:</strong>
                        <div style="margin: 6px 0; font-size: 0.9rem;"><strong style="color: #4285f4;">Google:</strong> High risk across all dimensions — highest education dependency (92%) and memory integration risk (90%). Requires immediate PLP intervention.</div>
                        <div style="margin: 6px 0; font-size: 0.9rem;"><strong style="color: #00a4ef;">Microsoft:</strong> High risk across most dimensions — high education dependency (87%) and lock-in risk (82%). Strategic priority for PLP alternatives.</div>
                        <div style="margin: 6px 0; font-size: 0.9rem;"><strong style="color: #ff6b35;">OpenAI:</strong> Medium-high risk — high lock-in risk (85%) but lower education dependency (65%). Growing risk as adoption increases.</div>
                        <div style="margin: 6px 0; font-size: 0.9rem;"><strong style="color: #d4a574;">Anthropic:</strong> Lower risk overall — lowest education dependency (45%) and openness risk (40%). Greatest opportunity for PLP partnership.</div>
                    </div>
                </div>
                <div class="chart-rationale-section" style="margin-top: 15px;">
                    <strong>How to Interpret:</strong>
                    <p>Color intensity (green → yellow → red) indicates risk level. Red cells (>80%) signal high risk where education is heavily dependent on closed memory systems, creating urgent need for PLP alternatives. Yellow cells (50-79%) indicate medium risk with room for intervention. Green cells (<50%) are lower risk areas with higher adoption potential for PLP. Horizontal patterns show provider strengths across risk categories; vertical patterns show which risk categories are most concerning across providers. Hover over cells to see detailed risk scores and interpretations.</p>
                </div>
                <div class="chart-rationale-section" style="margin-top: 15px;">
                    <strong>Strategic Actions:</strong>
                    <ul class="chart-rationale-list">
                        <li>Prioritize providers with >80% risk in multiple categories — Google and Microsoft require immediate PLP intervention</li>
                        <li>Target high-risk categories for PLP development — Memory Integration Risk and Education Dependency are critical intervention points</li>
                        <li>Focus on providers with lower overall risk (Anthropic) for early PLP partnerships — these offer strategic opportunities</li>
                        <li>Monitor risk increases over time — tracking shifts helps time PLP interventions before lock-in becomes irreversible</li>
                        <li>Use risk patterns to prioritize investment — allocate resources to categories and providers showing highest combined risk</li>
                    </ul>
                </div>
            `);
        }

        // Initialize dashboard
        window.addEventListener('load', function() {
            renderEcosystemModule();
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            const activeModule = document.querySelector('.dashboard-section.active').id;
            if (activeModule === 'module-ecosystem') renderEcosystemModule();
            else if (activeModule === 'module-memory') renderMemoryModule();
            else if (activeModule === 'module-education') renderEducationModule();
        });
    </script>
</body>
</html>
